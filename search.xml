<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenCV的Python实践(3)</title>
      <link href="/2019/05/18/OpenCvPythonPractice-3/"/>
      <url>/2019/05/18/OpenCvPythonPractice-3/</url>
      
        <content type="html"><![CDATA[<h2 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h2><a id="more"></a><p>&emsp;&emsp;图像梯度原理：简单来说就是求导。<br>&emsp;&emsp;OpenCV提供了三种不同的梯度滤波器，或者说高通滤波器：Sobel，Scharr和Laplacian。Sobel和Scharr是求一阶或二阶导数。Scharr是对Sobel（使用小的卷积核求解梯度角度时）的优化，Laplacian是求二阶导数。</p><ol><li>Sobel算子和Scharr算子<br>&emsp;&emsp;Sobel算子是高斯平滑与微分操作的结合体，它的抗噪音能力很好。可以设定求导的方向（xorder或yorder）。还可以设定使用的卷积核的大小（ksize），如果ksize=-1，会使用3x3的Scharr滤波器，效果会更好，若速度相同，在使用3x3滤波器时尽量使用Scharr。<br>&emsp;&emsp;3x3的Scharr滤波器卷积核如下：<ul><li>X方向</li></ul></li></ol><table><thead><tr><th style="text-align:center">-3</th><th style="text-align:center">0</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">-10</td><td style="text-align:center">0</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">-3</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr></tbody></table><pre><code>+ Y方向</code></pre><table><thead><tr><th style="text-align:center">-3</th><th style="text-align:center">-10</th><th style="text-align:center">-3</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10</td><td style="text-align:center">3</td></tr></tbody></table><p>2.Laplacian算子(拉普拉斯算子)<br>&emsp;&emsp;拉普拉斯算子可以使用二阶导数的形式定义，可假设其离散实现类似于二阶Sobel导数，事实上OpenCV在计算拉普拉斯算子时直接调用Sobel算子。<br>&emsp;&emsp;拉普拉斯滤波器使用的卷积核：<br><img src="/2019/05/18/OpenCvPythonPractice-3/tidu.jpg" alt="图"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#用以上三种滤波器对同一幅图像进行操作，卷积核使用为5x5。</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">laplacian = cv2.Laplacian(img,cv2.CV_64F)</span><br><span class="line">sobelx = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span><br><span class="line">sobely = cv2.Sobel(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'original'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),plt.imshow(laplacian,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'laplacian'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),plt.imshow(sobelx,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Sobel X'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),plt.imshow(sobely,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Sobel Y'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>当我们可以通过参数-1来设定输出图像的深度（数据类型）与原图像保持一致，但是我们在代码中使用的却是cv2.CV_64F。这是为什么？想象一下一个从黑到白的边界的导数是正数，而一个从白到黑的边界的导数却是负数。如果原图像的深度是np.int8时，所有的负值都会被截断变成0。换句话就是把边界丢失掉。<br>所以如果这两种边界你都想检测到，最好的办法就是将输出的数据类型设置的更高，比如cv2.CV_16S等，取绝对值然后再把它转回到cv2.CV_8U。</p><h2 id="Canny边缘检测原理"><a href="#Canny边缘检测原理" class="headerlink" title="Canny边缘检测原理"></a>Canny边缘检测原理</h2><ol><li>噪音去除<br>&emsp;&emsp;由于边缘检测很容易受到噪音影响，所以第一步是使用5x5的高斯滤波器去除噪音。</li><li>计算图像梯度<br>&emsp;&emsp;对平滑后的图像使用Sobel算子计算水平方向和竖直方向的一阶导数（图像梯度）（Gx和Gy）。根据得到的这两幅梯度图找到边界的梯度和方向。公式如下：<br><img src="/2019/05/18/OpenCvPythonPractice-3/bianyuan1.jpg" alt="图"><br>&emsp;&emsp;梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两条对角线。</li><li>非极大值抑制<br>&emsp;&emsp;在获得梯度的方向和大小之后，应该对整幅图想做一个扫描，出去那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。<br><img src="/2019/05/18/OpenCvPythonPractice-3/bianyuan2.jpg" alt="图"><br>&emsp;&emsp;现在你得到的是一个包含“窄边界”的二值图像。</li><li>滞后阀值<br>&emsp;&emsp;现在要确定那些边界才是真正的边界，需要设置两个阀值：minVal和maxVal。当图像的灰度梯度高于maxVal时被认为是真的边界，那些低于minVal的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正边界点相连，如果是，就认为它也是边界点，如果不是就抛弃。<h2 id="OpenCV中的Canny边界检测"><a href="#OpenCV中的Canny边界检测" class="headerlink" title="OpenCV中的Canny边界检测"></a>OpenCV中的Canny边界检测</h2>&emsp;&emsp;cv2.Canny()第一个参数是输入图像，第二和第三个分别是minVal和maxVal。第三个参数设置用来计算图像梯度的Sobel卷积核的大小，默认值为3。最后一个参数是L2gradient，它可以用来设定求梯度大小的方程。如果设为True，就使用我们上面提到过的方程，否则使用方程<br><img src="/2019/05/18/OpenCvPythonPractice-3/bianyuan3.jpg" alt="图">代替，默认为False<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img,<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'original'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(edges,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'edge'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol><h2 id="图像金字塔原理"><a href="#图像金字塔原理" class="headerlink" title="图像金字塔原理"></a>图像金字塔原理</h2><p>&emsp;&emsp;一般情况下，我们要处理是一副具有固定分辨率的图像。但是特别情况下我们需要对同一个图像的不同分辨率的子图像进行处理，如查找图像中的某个目标，如人脸，我们不知道目标在图像中的尺寸大小。这种情况下，我们需要创建一组图像，这些图像是具有不同分辨率的原始图像。我们把这组图像叫做图像金字塔。就是同一图像的不同分辨率的子图集合。我们把最大的图像放在底部，最小的放在顶部，看起来就像一座金字塔。有两类：高斯金字塔和拉普拉斯金字塔。</p><h2 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h2><p>&emsp;&emsp;高斯金字塔的顶部是通过将底部图像中的连续的行和列去除得到的。顶部图像中的每个像素值等于下一层图像中5个像素的高斯加权平均值。这样操作一次一个MxN的图像就变成了一个M/2xN/2的图像。所以这幅图像的面积就变为原来图像面积的四分之一。这被称为Octave。连续这样的操作，我们就会得到一个分辨率不断下降的图像金字塔。可以使用函数cv2.pyrDown()和cv2.pyrUp()构建图像金字塔。<br>&emsp;&emsp;cv2.pyrDown从一个高分辨率大尺寸的图像向上构建一个金字塔（尺寸变小，分辨率降低）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">lower_reso = cv2.pyrDown(img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'lower_reso'</span>,lower_reso)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey() == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;cv2.pyrUp从一个低分辨率小尺寸的图像向上构建一个金字塔（尺寸变大，但分辨率不会增加）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">lower_reso = cv2.pyrDown(img)</span><br><span class="line">higher_reso2 = cv2.pyrUp(img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'lower_reso'</span>,lower_reso)</span><br><span class="line">    cv2.imshow(<span class="string">'higher_reso2'</span>,higher_reso2)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey() == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>higher_reso2和higher_reso是不同的。因为一旦使用cv2.pyrDown图像的分辨率就会降低，信息就会被丢失。</p><h2 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h2><p>拉普拉斯金字塔可以由高斯金字塔计算得来。公式如下：<br><img src="/2019/05/18/OpenCvPythonPractice-3/jinzita1.jpg" alt="图"><br>拉普拉斯金字塔的图像看起来就像是边界图，其中很多像素都是0，常被用在图像压缩中。</p><h2 id="使用金字塔进行图像融合"><a href="#使用金字塔进行图像融合" class="headerlink" title="使用金字塔进行图像融合"></a>使用金字塔进行图像融合</h2><p>&emsp;&emsp;在图像缝合中，由于连接区域图像像素的不连续，整幅图看起来会很差，金字塔就可以实现无缝连接。<br>实现步骤：</p><ul><li>读入两幅图</li><li>构建各自的高斯金字塔(6层)</li><li>根据高斯金字塔计算拉普拉斯金字塔</li><li>在拉普拉斯的每一层进行图像融合</li><li>根据融合后的图像金字塔重建原始图像<br>&emsp;&emsp;重建原始图像过程：<br><img src="/2019/05/18/OpenCvPythonPractice-3/jinzita2.jpg" alt="图"><h2 id="什么是轮廓"><a href="#什么是轮廓" class="headerlink" title="什么是轮廓"></a>什么是轮廓</h2>&emsp;&emsp;轮廓可以简单认为成连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。</li><li>为了准确，要使用二值化图像。需要进行阀值化处理或者Canny边界检测。</li><li>查找轮廓的函数会修改原始图像。如果之后想继续使用原始图像，应该将原始图像储存到其他变量中。</li><li>OpenCV中，查找轮廓就像在黑色背景中超白色物体。你应该记住，要找的物体应该是白色而背景应该是黑色。</li><li>在二值图像中查找轮廓使用函数cv2.findContours(),有三个参数，第一个是输入图像，第二个是轮廓检索模式，第三个是轮廓近似方法。返回值有三个，第一个是图像，第二个是轮廓，第三个是（轮廓的）层析结构。轮廓（第二个返回值）是一个Python列表，其中储存这图像中所有轮廓。每一个轮廓都是一个Numpy数组，包含对象边界点（x，y）的坐标。<h2 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h2>&emsp;&emsp;函数cv2.drawContours()可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。它的第一个参数是原始图像，第二个参数是轮廓，一个python列表，第三个参数是轮廓的索引（在绘制独立轮廓是很有用，当设置为-1时绘制所有轮廓）。接下来的参数是轮廓的颜色和厚度。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">imgray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret,thresh = cv2.threshold(imgray,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"><span class="comment">#绘制独立轮廓，如第四个轮廓</span></span><br><span class="line">imag = cv2.drawContours(img,contours,<span class="number">-1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line"><span class="comment">#但是大多数时候，下面方法更有用</span></span><br><span class="line"><span class="comment">#imag = cv2.drawContours(img,contours,3,(0,255,0),3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'imgray'</span>,imgray)</span><br><span class="line">    cv2.imshow(<span class="string">'imag'</span>,imag)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li></ul><h2 id="轮廓的近似方法"><a href="#轮廓的近似方法" class="headerlink" title="轮廓的近似方法"></a>轮廓的近似方法</h2><p>&emsp;&emsp;之前提到轮廓是一个形状具有相同灰度值的边界，它会存储形状边界上所有的（x,y）坐标。实际上我们不需要所有的点，当需要直线时，找到两个端点即可。cv2.CHAIN_APPROX_SIMPLE可以实现。它会将轮廓上的冗余点去掉，压缩轮廓，从而节省内存开支。<br>&emsp;&emsp;下面用矩阵来演示，在轮廓列表中的每一个坐标上画一个蓝色圆圈。第一个显示使用cv2.CHAIN_APPROX_NONE的效果，一共734个点，第二个图是使用cv2.CHAIN_APPROX_SIMPLE的结果，只有4个点。<br><img src="/2019/05/18/OpenCvPythonPractice-3/lunkuo1.jpg" alt="图"></p><h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><ol><li><p>矩<br>&emsp;&emsp;图像的矩可以帮助我们计算图像的质心，面积等。<br>&emsp;&emsp;函数cv2.moments()会将计算得到的矩以一个字典的形式返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy=cv2.findContours(thresh,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">cnt=contours[<span class="number">0</span>]</span><br><span class="line">M=cv2.moments(cnt)</span><br><span class="line">print(M)</span><br><span class="line"><span class="comment">#根据这些矩的值，我们可以计算出对象的重心</span></span><br><span class="line">cx=int(M[<span class="string">'m10'</span>]/M[<span class="string">'m00'</span>])</span><br><span class="line">cy=int(M[<span class="string">'m01'</span>]/M[<span class="string">'m00'</span>])</span><br></pre></td></tr></table></figure></li><li><p>轮廓面积<br>&emsp;&emsp;可以使用函数cv2.contourArea()计算得到，也可以用矩（0阶矩），M[‘m00’]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area=cv2.contourArea(cnt)</span><br></pre></td></tr></table></figure></li><li><p>轮廓周长<br>&emsp;&emsp;也被称为弧长。可以使用函数cv2.arcLength()计算得到。这个函数的第二参数可以用来指定对象的形状是闭合的（True），还是打开的（一条曲线）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt,<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>轮廓近似<br>&emsp;&emsp;将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定，使用的Douglas-Peucker算法，可以自己Google。假设我们要在一幅图像中查找一个矩形，但是由于图像的种种原因我们不能得到一个完美的矩形，而是一个“坏形状”，现在就可以使用这个函数来近似这个形状，第二个参数是epsilon，它是从原始轮廓到近似轮廓的最大距离，它是一个准确度参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilon=<span class="number">0.1</span>*cv2.arcLength(cnt,<span class="literal">True</span>)</span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>凸包<br>&emsp;&emsp;凸包与轮廓近似相似，但不同，虽然有些情况下它们给出的结果是一样的。函数cv2.convexHull()可以用来检测一个曲线是否具有凸性缺陷，并能纠正缺陷。一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去了就被叫做凸性缺陷。例如下图中的手，红色曲线显示了手的凸包，凸性缺陷被双箭头标出来了。<br><img src="/2019/05/18/OpenCvPythonPractice-3/lunkuo2.jpg" alt="图"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(points,hull,clockwise,returnPoints)</span><br><span class="line"><span class="comment">#points 我们要传入的轮廓</span></span><br><span class="line"><span class="comment">#hull 输出，通常不需要</span></span><br><span class="line"><span class="comment">#clockwise 方向标志，如果设置为True，输出的凸包是顺时针方向的，否则为逆时针方向。</span></span><br><span class="line"><span class="comment">#returnPoints默认值为True。它会返回凸包上点的坐标，如果设置为False，就会返回与凸包点对应的轮廓上的点。</span></span><br><span class="line">要获得上图的凸包，可以用下面命令：</span><br><span class="line">hull=cv2.convexHull(cnt)</span><br></pre></td></tr></table></figure></li></ol><p>但是如果你想获得凸性缺陷，需要把returnPoints设置为False。以上面矩形为例，首先我们找到他的轮廓从cnt。现在把returnPoints设置为True查找凸包，得到的就是矩形的四个角点。把returnPoints设置为False，得到的是轮廓点的索引。</p><ol start="6"><li><p>凸性检测<br>&emsp;&emsp;函数cv2.isContourConvex()可以检测一个曲线是不是凸的。它只能返回True或者False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k=cv2.isContourConvex(cnt)</span><br></pre></td></tr></table></figure></li><li><p>边界矩形<br>&emsp;&emsp;直边界矩形，一个直矩形，没有旋转。不会考虑对象是否旋转。所以边界矩形的面积不是最小的。可以使用函数cv2.boundingRect()查找得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（x,y）为矩形左上角的坐标，（w,h）是矩形的宽和高</span></span><br><span class="line">x,y,w,h=cv2.boundingRect(cnt)</span><br><span class="line">img=cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p>旋转的边界矩形，这个边界矩形是面积最小的，因为它考虑了对象的旋转。用函数cv2.minAreaRect()。返回的是一个Box2D结构，其中包含矩形最上角角点坐标（x，y）矩形的宽和高（w,h）以及旋转角度。但是要绘制这个矩形需要矩形的4个角点，可以通过函数cv2.boxPoints()获得。<br>其中绿色的为直矩形，红色为旋转矩形。<br><img src="/2019/05/18/OpenCvPythonPractice-3/lunkuo3.jpg" alt="图"></p><ol start="8"><li>最小外接圆<br>&emsp;&emsp;函数cv2.minEnclosingCircle()可以帮我们找到一个对象的外接圆。它是所有能够包括对象的圆中面积最小的一个。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x,y),radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">center = (int(x),int(y))</span><br><span class="line">radius = int(radius)</span><br><span class="line">img = cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/05/18/OpenCvPythonPractice-3/lunkuo4.jpg" alt="图"></p><ol start="9"><li>椭圆拟合<br>&emsp;&emsp;使用函数cv2.ellipse()，返回值其实就是旋转边界矩形的内切圆。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">img = cv2.ellipse(img,ellipse,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/05/18/OpenCvPythonPractice-3/lunkuo5.jpg" alt="图"></p><ol start="10"><li>直线拟合<br>&emsp;&emsp;可以根据一组点拟合出一条直线，同样我们也可以为图像中的白色点拟合出一条直线。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span><br><span class="line">[vx,vy,x,y]=cv2.fitLine(cnt,cv2.DIST_L2,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>)</span><br><span class="line">lefty=int((x*vy/vx)+y)</span><br><span class="line">righty=int(((cols-x)*vy/vx)+y)</span><br><span class="line">img = cv2.line(img,(cols<span class="number">-1</span>,righty),(<span class="number">0</span>,lefty),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/05/18/OpenCvPythonPractice-3/lunkuo6.jpg" alt="图"></p><h2 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h2><ol><li><p>长宽比<br>边界矩形的宽高比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x,y,w,h=cv2.boundingRect(cnt)</span><br><span class="line">aspect_ratio = float(w)/h</span><br></pre></td></tr></table></figure></li><li><p>Extent<br>轮廓面积与边界矩形面积的比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area=cv2.contourArea(cnt)</span><br><span class="line">x,y,w,h=cv2.boundingRect(cnt)</span><br><span class="line">rect_area=w*h</span><br><span class="line">extent=float(area)/rect_area</span><br></pre></td></tr></table></figure></li><li><p>Solidity<br>轮廓面积与凸包面积的比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area=cv2.contourArea(cnt)</span><br><span class="line">hull=cv2.convexHull(cnt)</span><br><span class="line">hull_area=cv2.contourArea(hull)</span><br><span class="line">solidity=float(area)/hull_area</span><br></pre></td></tr></table></figure></li><li><p>与轮廓面积相等的圆形的直径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area=cv2.contourArea(cnt)</span><br><span class="line">equi_diameter=np.sqrt(<span class="number">4</span>*area/np.pi)</span><br></pre></td></tr></table></figure></li><li><p>方向<br>对象的方向，下面的方法还会返回长轴和短轴的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x,y),(MA,ma),angle=cv2.fitEllipse(cnt)</span><br></pre></td></tr></table></figure></li><li><p>掩模和像素点<br>有时我们需要构成对象的所有像素点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mask=np.zeros(imgray.shate,np.uint8)</span><br><span class="line"><span class="comment">#这里一定要使用参数-1，绘制填充的轮廓</span></span><br><span class="line">cv2.drawContours(mask,[cnt],<span class="number">0</span>,<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">pixelpoints=np.transpose(np.nonzero(mask))</span><br></pre></td></tr></table></figure></li><li><p>最大值和最小值及它们的位置<br>可以使用掩模图像得到这些参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val,max_val,min_loc,max_loc=cv2.minMaxLoc(imgray,mask=mask)</span><br></pre></td></tr></table></figure></li><li><p>平均颜色及平均灰度<br>同样使用相同的掩模来求得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_val=cv2.mean(im,mask=mask)</span><br></pre></td></tr></table></figure></li></ol><p>9.极点<br>一个对象最上，最下，最左，和最右的点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftmost=tuple(cnt[cnt[:,:,<span class="number">0</span>].argmin()[<span class="number">0</span>])</span><br><span class="line">rightmost=tuple(cnt[cnt[:,:,<span class="number">0</span>].argmax()[<span class="number">0</span>])</span><br><span class="line">topmost=tuple(cnt[cnt[:,:,<span class="number">1</span>].argmin()[<span class="number">0</span>])</span><br><span class="line">bottommost=tuple(cnt[cnt[:,:,<span class="number">1</span>].argmax()[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><h2 id="轮廓：更多函数"><a href="#轮廓：更多函数" class="headerlink" title="轮廓：更多函数"></a>轮廓：更多函数</h2><ol><li>凸缺陷<br>找到凸缺陷<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hull=cv2.convexHull(cnt,returnPoints=<span class="literal">False</span>)</span><br><span class="line">defects=cv2.convexityDefects(cnt,hull)</span><br></pre></td></tr></table></figure></li></ol><p>它会返回一个数组，其中每一行包含的值是[起点，终点，最远的点，到最远点的近似距离]</p><ol start="2"><li>Point Polygon Test<br>求解图像中的一个点到一个对象轮廓的最短距离。如果点再轮廓的外部，返回值为负，如果在轮廓上，返回值为0，如果在轮廓内部，返回值为正。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist = cv2.pointPolygonTest(cnt,(<span class="number">50</span>,<span class="number">50</span>),<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ol><p>此函数的第三个参数是measureDist。如果设置为True，就会计算最短距离。如果是False，只会判断这个点与轮廓之间的位置关系（返回值为+1,-1,0）</p><ol start="3"><li>形状匹配<br>函数cv2.matchShape()可以帮我们比较两个形状或者轮廓的相似度，如果返回值越小，匹配越好，它是根据Hu矩来计算的。</li></ol><h2 id="轮廓的层次结构"><a href="#轮廓的层次结构" class="headerlink" title="轮廓的层次结构"></a>轮廓的层次结构</h2><ol><li>什么是层次结构<br>&emsp;&emsp;通常我们使用函数cv2.findContours 在图片中查找一个对象。有时对象可能位于不同的位置。还有些情况，一个形状在另外一个形状的内部，这种情况下我们称外部的形状为父，内部的形状为子。按照这种方式分类，一幅图像中的所有轮廓之间就建立父子关系。这样我们就可以确定一个轮廓与其他轮廓是怎样连接的，比如它是不是某个轮廓的子轮廓，或者是父轮廓。这种关系就成为组织结构。</li><li>opencv中层次结构<br>OpenCV使用一个含有四个元素的数组表示父子关系，【Next，Previous，First_Child，Parent】<br>Next表示同一级组织结构中的下一个轮廓。<br>Previous 示同一级结构中的前一个轮廓。<br>First_Child 示它的第一个子轮廓。<br>Parent 示它的父轮廓。</li><li>轮廓检索模式<br>RETR_LIST 从的度来看中应是简单的。它只是提取所有的轮廓而不去创建任何父子关系。换句就是‘’人人平等‘’它们属于同一级组织轮廓。<br>所以在种情况下组织结构数组的第三和第四个数是 -1。但是很明 显Next 和 Previous 有对应的值。<br>RETR_EXTERNAL 如果你择种模式的只会回外的的轮廓，所有的子轮廓会忽略掉。</li></ol><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><ol><li>直方图原理<br>通过直方图可以对整幅图像的灰度分布有一个整体的了解。直方图的X轴是灰度值（0,255），Y轴是图片中具有同一个灰度值的点的数目。<br>通过直方图我们可以对图像的对比度，亮度，灰度分布等有一个直观的认识。相关术语：<ul><li>BINS:每个灰度值对应的像素数。如果像素值为0到255，就需要256个数来显示上面的直方图。</li><li>DIMS:收集数据的参数数目。</li><li>RANGE:要统计的灰度值范围，一般[0,256].</li></ul></li><li>函数cv2.calcHist可以统计一幅图像的直方图。<br>cv2.calcHist(images,channels,mask,histSize,range[,hist[,accumulate]])<ul><li>images:原图像(格式uint8或float32),传入函数时应用中括号括起来，如[img]</li><li>channels:传入函数时应用中括号括起来</li><li>mask:掩模图像</li><li>histSize:BIN的数目，应用中括号括起来，如[256]</li><li>ranges:像素范围，通常[0,256]</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> OpenCV的Python实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV的Python实践(2)</title>
      <link href="/2019/05/18/OpenCvPythonPractice-2/"/>
      <url>/2019/05/18/OpenCvPythonPractice-2/</url>
      
        <content type="html"><![CDATA[<h2 id="几何变换—扩展缩放"><a href="#几何变换—扩展缩放" class="headerlink" title="几何变换—扩展缩放"></a>几何变换—扩展缩放</h2><a id="more"></a><p>&emsp;&emsp;只是改变图像的尺寸大小，cv2.resize()可以实现这个功能。在缩放时推荐cv2.INTER_AREA，在拓展时推荐cv2.INTER_CUBIC（慢）和cv2.INTER_LINEAR。默认情况下所有改变图像尺寸大小的操作使用的是插值法都是cv2.INTER_LINEAR。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line"><span class="comment">#下面的None本应该是输出图像的尺寸，但是因为后面设置了缩放因子，所以，这里为None</span></span><br><span class="line">res = cv2.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>,fy=<span class="number">2</span>,interpolation=cv2.INTER_CUBIC)</span><br><span class="line"><span class="comment">#这里直接设置输出图像的尺寸，所以不用设置缩放因子</span></span><br><span class="line">height,width =img.shape[:<span class="number">2</span>]</span><br><span class="line">res = cv2.resize(img,(<span class="number">2</span>*width,<span class="number">2</span>*height),interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>,res)</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="几何变换—平移"><a href="#几何变换—平移" class="headerlink" title="几何变换—平移"></a>几何变换—平移</h2><p>&emsp;&emsp;如果想要沿（x，y）方向移动，移动的距离为（t<sub>x</sub>,t<sub>y</sub>）可以以下面方式构建<strong>移动矩阵</strong>。<br><img src="/2019/05/18/OpenCvPythonPractice-2/移动矩阵.jpg" alt="图"><br>&emsp;&emsp;使用Numpy数组构建矩阵，数据类型是np.float32，然后传给函数cv2.warpAffine()<br>函数cv2.warpAffine() 的第三个参数的是输出图像的大小，它的格式<br>应该是图像的（宽，高）。应该记住的是图像的宽对应的是列数，高对应的是行数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#将图像平移到到点（200,100）处</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">img=cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">rows,cols=img.shape[:<span class="number">2</span>]</span><br><span class="line">M= np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">200</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>]])</span><br><span class="line">dst = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line">cv2.imshow(<span class="string">'img'</span>, dst)</span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> k == ord(<span class="string">'s'</span>):</span><br><span class="line">    cv2.imwrite(<span class="string">'show'</span>, dst)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="几何变换—旋转"><a href="#几何变换—旋转" class="headerlink" title="几何变换—旋转"></a>几何变换—旋转</h2><p>&emsp;&emsp;对一个图像旋转角度θ，需要使用下面的旋转矩阵。<br><img src="/2019/05/18/OpenCvPythonPractice-2/旋转矩阵0.jpg" alt="图"><br>&emsp;&emsp;但OpenCV允许在任意地方进行旋转，所以矩阵应该为：<br><img src="/2019/05/18/OpenCvPythonPractice-2/旋转矩阵1.jpg" alt="图"><br>&emsp;&emsp;为构建旋转矩阵，OpenCV提供了一个函数cv2.getRotationMatrix2D。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">rows,cols=img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的第一个参数为旋转中心，第二个为旋转角度，第三个为旋转后的缩放因子</span></span><br><span class="line"><span class="comment">#可以通过设置旋转中心，缩放因子以及窗口大小来防止旋转后超出边界的问题。</span></span><br><span class="line"></span><br><span class="line">M=cv2.getRotationMatrix2D((cols/<span class="number">2</span>,rows/<span class="number">2</span>),<span class="number">45</span>,<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三个参数是输出图像的尺寸中心</span></span><br><span class="line"></span><br><span class="line">dst=cv2.warpAffine(img,M,(<span class="number">1</span>*cols,<span class="number">1</span>*rows))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,dst)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="几何变换—仿射变换"><a href="#几何变换—仿射变换" class="headerlink" title="几何变换—仿射变换"></a>几何变换—仿射变换</h2><p>&emsp;&emsp;仿射变换就是图像的线性变换加上平移，用一幅图表示，就是<br><img src="/2019/05/18/OpenCvPythonPractice-2/仿射变化0.jpg" alt="图"><br>&emsp;&emsp;由image1到image2经过了三个操作</p><ol><li>旋转(线性变化)</li><li>缩放(线性变化)</li><li>平移(向量加)<br>如果没有了第3个平移的操作，那它就是线性变换。<br>&emsp;&emsp;图像的变换要对图像的每一个像素点进行操作，假设其中的一个像素点的坐标是（x,y），我们用矩阵形式表示：<br><img src="/2019/05/18/OpenCvPythonPractice-2/仿射变化-dian.jpg" alt="图"><br>我们通常使用2x3矩阵来表示仿射变换:<br><img src="/2019/05/18/OpenCvPythonPractice-2/仿射变化-jz.jpg" alt="图"><br>经过仿射变换后的点的矩阵坐标是T，我们已经知道仿射变换就是线性变换加上平移，用矩阵表示的话就是:<br><img src="/2019/05/18/OpenCvPythonPractice-2/仿射变化-jz2.jpg" alt="图"><br>计算可得，点的坐标经过仿射变换后成为：<br><img src="/2019/05/18/OpenCvPythonPractice-2/仿射变化-jz3.jpg" alt="图"><br>&emsp;&emsp;观察之前平移，旋转的代码，其中的都有dst = cv2.warpAffine(img, M, (cols, rows))，之所以是平移，是旋转，只是其中的变化矩阵M不同。<br>&emsp;&emsp;在仿射变换中，原图中所有平行线在结果图像中同样平行。为创建这个矩阵，需要从原图像中找到三个点以及他们在输出图像中的位置，然后cv2.getAffineTransForm()会创建一个2X3的矩阵。最后这个矩阵会被传给函数cv2.warpAffine()。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">rows,cols,ch=img.shape[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">pts1=np.float32([[<span class="number">0</span>,<span class="number">0</span>],[cols<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">0</span>,rows<span class="number">-1</span>]])</span><br><span class="line">pts2=np.float32([[cols*<span class="number">0.2</span>,rows*<span class="number">0.1</span>],[cols*<span class="number">0.9</span>,rows*<span class="number">0.2</span>],[cols*<span class="number">0.1</span>,rows*<span class="number">0.9</span>]])</span><br><span class="line">M=cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">dst=cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,dst)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li></ol><h2 id="几何变换—透视变换"><a href="#几何变换—透视变换" class="headerlink" title="几何变换—透视变换"></a>几何变换—透视变换</h2><p>&emsp;&emsp;对于视角变换，我们需要一个3x3变换矩阵。在变换前后直线还是直线。需要在原图上找到4个点，以及他们在输出图上对应的位置，这四个点中任意三个都不能共线，可以有函数cv2.getPerspectiveTransform()构建，然后这个矩阵传给函数cv2.warpPerspective()。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">rows,cols,ch=img.shape[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">M=cv2.getPerspectiveTransform(pts1,pts2)</span><br><span class="line">dst=cv2.warpPerspective(img,M,(cols,rows))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,dst)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><blockquote><p>旋转和平移都是仿射变换的特殊形式<br>OpenCV中提供warpAffine函数用来实现仿射变换,该函数要求提供用来进行仿射变换的矩阵（2x3），如果不知道该变换矩阵，可以结合两幅图像上三对对应点利用getAffineTransform函数求得仿射变换矩阵。<br>透视变换的本质是将图像投影到一个新的视平面。仿射变换可以理解为透视变换的特殊形式。<br>一幅图像就是一个像素坐标系下的各个带有像素值的坐标点，而透视变换可以理解为就是将一幅图像中的这些坐标点完成了一个坐标转换，将它们的坐标变换到了其他位置，从而实现了变换了图像视角的效果。<br>透视变换可以用透视变换矩阵完成，透视变换矩阵为3x3矩阵:<br><img src="/2019/05/18/OpenCvPythonPractice-2/透视变化矩阵.jpg" alt="图"><br>矩阵可以分块来看，T<sub>1</sub>表示图像线性变换（包括旋转和缩放）、T<sub>2</sub>表示图像平移，T<sub>3</sub>用于产生图像透视变换，a<sub>33</sub>一般为1。透视变换矩阵一般有8个未知数，给定透视变换对应的四对像素点坐标，即可求得透视变换矩阵；反之，给定透视变换矩阵，即可对图像或像素点坐标完成透视变换。<br>仿射变换需要三组点的对应关系，而透视变换需要四组点的对应关系，才可以分别求得仿射变换和透视变换的变换矩阵。</p></blockquote><h2 id="简单阀值"><a href="#简单阀值" class="headerlink" title="简单阀值"></a>简单阀值</h2><p>&emsp;&emsp;实现函数为cv2.threshold , cv2.adaptiveThreshold等<br>&emsp;&emsp;当像素值高于阀值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。这个函数就是cv2.threshold()。这个函数的第一个参数就是原图像，原图像应该是灰度图。第二个参数就是用来对像素值进行分类的阀值，第三个参数就是当像素值高于（或者小于）阀值时，应该被赋予新的像素值。OpenCV提供了多种不同的阀值方法，这是有第四个参数来决定的。方法包括</p><ul><li>cv2.THRESH_BINARY</li><li>cv2.THRESH_BINARY_INV</li><li>cv2.THRESH_TRUNC</li><li>cv2.THRESH_TOZERO</li><li>cv2.THRESH_TOZERO_INV<br><img src="/2019/05/18/OpenCvPythonPractice-2/简单阀值.jpg" alt="图"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb3.jpg'</span>)</span><br><span class="line">ret , thresh1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">ret , thresh2 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">ret , thresh3 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">ret , thresh4 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">ret , thresh5 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'original image'</span>,<span class="string">'Binary'</span>,<span class="string">'binary-inv'</span>,<span class="string">'trunc'</span>,<span class="string">'tozero'</span>,<span class="string">'tozero-inv'</span>]</span><br><span class="line">images = [img,thresh1,thresh2,thresh3,thresh4,thresh5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul><h2 id="自适应阀值"><a href="#自适应阀值" class="headerlink" title="自适应阀值"></a>自适应阀值</h2><p>&emsp;&emsp;根据图像上的每一个小区域计算与其对应的阀值。因此在同一幅图像上的不同区域采用的是不同的阀值，从而使我们能在亮度不同的情况下得到更好的结果。<br>&emsp;&emsp;这种方法需要我们指定三个参数，返回值只有一个:</p><ul><li>Adaptive Method :指定计算阀值的方法<ul><li>cv2.ADAPTIVE_THRESH_MEAN_C:阀值取自相邻区域的平均值</li><li>cv2.ADAPTIVE_THRESH_GAUSSIAN_C:阀值取自相邻区域的加权和，权重为一个高斯窗口</li></ul></li><li>Block Size :邻域大小（用来计算阀值的区域大小）</li><li>C :这就是一个常数，阀值就等于的平均值或者加权平均值减去这个常数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb3.jpg'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#中值滤波</span></span><br><span class="line">img = cv2.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">ret , th1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 11为block size，2为C值</span></span><br><span class="line">th2 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_MEAN_C , cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span> )</span><br><span class="line">th3 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C , cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'original image'</span> , <span class="string">'global thresholding (v=127)'</span>,<span class="string">'Adaptive mean thresholding'</span>,</span><br><span class="line">          <span class="string">'adaptive gaussian thresholding'</span>]</span><br><span class="line">images = [img,th1,th2,th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Otsu’s二值化"><a href="#Otsu’s二值化" class="headerlink" title="Otsu’s二值化"></a>Otsu’s二值化</h2><p>&emsp;&emsp;在使用全局阈值时，随便给了一个数来做阈值，那怎么知道选取的这个数的好坏呢？答案就是不停的尝试。如果是一副双峰图像（简单来说双峰图像是指图像直方图中存在两个峰）呢？我们岂不是应该在两个峰 之间的峰谷选一个值作为阈值？这就是Otsu二值化要做的。简单来说就是对一副双峰图像自动根据其直方图计算出一个阈值。（对于非双峰图像，这种方法得到的结果可能会不理想）。<br>&emsp;&emsp;这里用到到的函数还是 cv2.threshold()，但是需要多传入一个参数 （ﬂag）：cv2.THRESH_OTSU。这时要把阈值设为 0。然后算法会找到最优阈值，这个最优阈值就是返回值 retVal。如果不使用 Otsu 二值化，返回的 retVal 值与设定的阈值相等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">'psb3.jpg'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret1,th1=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">ret2,th2=cv2.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment">#(5,5)为高斯核的大小，0为标准差</span></span><br><span class="line">blur= cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#阀值一定要设为0</span></span><br><span class="line">ret3,th3=cv2.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line">images=[img,<span class="number">0</span>,th1,</span><br><span class="line">         img,<span class="number">0</span>,th2,</span><br><span class="line">         img,<span class="number">0</span>,th3]</span><br><span class="line">titles =[<span class="string">'original noisy image'</span>,<span class="string">'histogram'</span>,<span class="string">'global thresholding(v=127)'</span>,</span><br><span class="line">          <span class="string">'original noisy image'</span>,<span class="string">'histogram'</span>,<span class="string">"otsu's thresholding"</span>,</span><br><span class="line">          <span class="string">'gaussian giltered image'</span>,<span class="string">'histogram'</span>,<span class="string">"otus's thresholding"</span>]</span><br><span class="line"><span class="comment">#这里使用了pyplot中画直方图的方法，plt.hist要注意的是他的参数是一维数组</span></span><br><span class="line"><span class="comment">#所以这里使用了（numpy）ravel方法，将多维数组转换成一维，也可以使用flatten方法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]),plt.xticks([]),plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]),plt.xticks([]),plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]),plt.xticks([]),plt.yticks([])</span><br><span class="line">    </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><h2 id="2D卷积"><a href="#2D卷积" class="headerlink" title="2D卷积"></a>2D卷积</h2><p>同一维信号一样，可以对2D图像实施低通滤波（LPF）和高通滤波（HPF）。LPF用于去除噪音，模糊图像，HPF用于找到图像的边缘。<br>OpenCV提供的函数cv.filter2D()可以对一幅图像进行卷积操作。练习一幅图像使用平均滤波器。举例下面是一个5X5的平均滤波器核：<br><img src="/2019/05/18/OpenCvPythonPractice-2/2D卷积.jpg" alt="图"><br>操作如下，将核放在图像的一个像素A上，求与核对应的图像上25（5x5）个像素的和，再取平均数，用这个平均数代替像素A的值。重复以上操作直到将图像的每一个像素值都更新一遍。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line"></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv.Filter2D(src, dst, kernel, anchor=(-1, -1))</span></span><br><span class="line"><span class="comment">#ddepth –desired depth of the destination image;</span></span><br><span class="line"><span class="comment">#if it is negative, it will be the same as src.depth();</span></span><br><span class="line"><span class="comment">#the following combinations of src.depth() and ddepth are supported:</span></span><br><span class="line"><span class="comment">#src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F</span></span><br><span class="line"><span class="comment">#src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F</span></span><br><span class="line"><span class="comment">#src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F</span></span><br><span class="line"><span class="comment">#src.depth() = CV_64F, ddepth = -1/CV_64F</span></span><br><span class="line"><span class="comment">#when ddepth=-1, the output image will have the same depth as the source.</span></span><br><span class="line"></span><br><span class="line">dst = cv2.filter2D(img,<span class="number">-1</span>,kernel)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'original'</span>)</span><br><span class="line">plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">'averaging'</span>)</span><br><span class="line">plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><h2 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h2><p>这是由一个归一化卷积框完成的，他只是用卷积框覆盖区域所有像素的平均值来代替中心元素。可以使用cv2.blur()和cv2.boxFilter()来实现， 我们需要设定卷积框的宽和高。同样是一个矩阵。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line"></span><br><span class="line">blur = cv2.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'blur'</span>,blur)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>&emsp;&emsp;现在把卷积核换成高斯核，简单的说方框不变，将原来每个方框的值是相等的，现在里面的值是符合高斯分布的，方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包，原来的求平均数变成求加权平均数，权就是方框里的值。实现的函数是cv2.GaussianBlur()。需要指定高斯核的宽和高（必须是奇数），以及高斯函数沿X,Y方向的标准差。如果我们只指定了X方向的标准差，Y方向也会取相同值，如果两个标准差都是0.那么函数会根据核函数的大小自己计算，高斯滤波可以有效的从图像中去除高斯噪音。<br>&emsp;&emsp;也可以使用cv2.getGaussianKernel()自己构建一个高斯核。<br>&emsp;&emsp;如果要使用高斯模糊的话，上边的代码应改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0是指根据窗口大小（5,5）来计算高斯函数标准差</span></span><br><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'blur'</span>,blur)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h2><p>就是用与卷积框对应像素的中值来替代中心像素的值，这个滤波器经常用来去除椒盐噪声。前面的滤波器都是用计算得到的一个新值来取代中心像素的值，而中值滤波是用中心像素周围或者本身的值来取代他，他能有效去除噪声。卷积核的大小也应该是一个奇数。<br>需要给原始图像加上50%的噪声，然后用中值模糊。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line"></span><br><span class="line">median = cv2.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'blur'</span>,median)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h2><p>函数cv2.bilateralFilter()能在保持边界清晰的情况下有效的去除噪音，但比较慢。这种高斯滤波器只考虑像素之间的空间关系，而不会考虑像素值之间的关系（像素的相似度），所以这种方法不会考虑一个像素是否位于边界，因此边界也会被模糊掉。<br>双边滤波在同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以能保证边界不会被模糊，因此边界处的灰度值变化比较大。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9 邻域直径，两个 75 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差 </span></span><br><span class="line">blur = cv2.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'blur'</span>,blur)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–腐蚀"><a href="#形态学–腐蚀" class="headerlink" title="形态学–腐蚀"></a>形态学–腐蚀</h2><p>&emsp;&emsp;形态学转换原理：一般情况下对二值化图像进行操作。需要两个参数，一个是原始图像，第二个被称为结构化元素或者核，它是用来决定操作的性质的。基本操作为腐蚀和膨胀，他们的变体构成了开运算，闭运算，梯度等。常用函数cv2.erode(),cv2.dilate(),cv2.morphotogyEx()。<br>&emsp;&emsp;腐蚀：把前景物体的边界腐蚀掉，但是前景仍然是白色的。卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是1，那么中心元素就保持原来的像素值，否则就变为零。根据卷积核的大小靠近前景的所有像素都会被腐蚀掉（变为0），所以前景物体会变小，整幅图像的白色区域会减少。这对于去除白噪音很有用，也可以用来断开两个连在一块的物体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv2.erode(img,kernel,iterations=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'erosion'</span>,erosion)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–膨胀"><a href="#形态学–膨胀" class="headerlink" title="形态学–膨胀"></a>形态学–膨胀</h2><p>&emsp;&emsp;与腐蚀相反，与卷积核对应的原图像的像素值中只要有一个是1，中心元素的像素值就是1。所以这个操作会增加图像中白色区域（前景）。一般在去噪音时先腐蚀再膨胀，因为腐蚀再去掉白噪音的同时，也会使前景对象变小，所以我们再膨胀。这时噪音已经被去除，不会再回来了，但是前景还在并会增加，膨胀也可以用来连接两个分开的物体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">dilation = cv2.dilate(img,kernel,iterations=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'dilation'</span>,dilation)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–开运算"><a href="#形态学–开运算" class="headerlink" title="形态学–开运算"></a>形态学–开运算</h2><p>先进行腐蚀再进行膨胀就叫做开运算。被用来去除噪音，函数可以使用cv2.morphologyEx()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">opening = cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'opening'</span>,opening)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–闭运算"><a href="#形态学–闭运算" class="headerlink" title="形态学–闭运算"></a>形态学–闭运算</h2><p>先膨胀再腐蚀。被用来填充前景物体中的小洞，或者前景上的小黑点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">closing = cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'closing'</span>,closing)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–梯度"><a href="#形态学–梯度" class="headerlink" title="形态学–梯度"></a>形态学–梯度</h2><p>其实就是一幅图像膨胀与腐蚀的差别。结果看上去就像前景物体的轮廓。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">gradient = cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'gradient'</span>,gradient)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–礼帽"><a href="#形态学–礼帽" class="headerlink" title="形态学–礼帽"></a>形态学–礼帽</h2><p>原始图像与进行开运算之后得到的图像的差。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">tophat = cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'tophat'</span>,tophat)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="形态学–黑帽"><a href="#形态学–黑帽" class="headerlink" title="形态学–黑帽"></a>形态学–黑帽</h2><p>进行闭运算之后得到的图像与原始图像的差。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'psb.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">blackhat = cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    cv2.imshow(<span class="string">'blackhat'</span>,blackhat)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'q'</span>):<span class="comment">#按q键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV的Python实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV的Python实践(1)</title>
      <link href="/2019/05/16/OpenCvPythonPractice-1/"/>
      <url>/2019/05/16/OpenCvPythonPractice-1/</url>
      
        <content type="html"><![CDATA[<h2 id="升级pip"><a href="#升级pip" class="headerlink" title="升级pip"></a>升级pip</h2><a id="more"></a><p>window的cmd模式下查询当前pip版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip show pip</span><br></pre></td></tr></table></figure></p><p>window的cmd模式下升级pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;安装cv2的时候出现”Requirement already satisfied”的问题无法使用python -m pip install opencv-python自动安装，可能是因为我的python版本经常换来换去的原因。通过指定安装路径解决，启动自动安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --target=D:\Python27_13\Lib\site-packages opencv-python</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;好吧，可能因为网络原因，我的网是真的慢，安装到一半还是失败，但是获取了相关whl的信息，我直接去下载这个opencv_python-4.1.0.25-cp36-cp36m-win32.whl来手动安装。用迅雷下载这个25兆的文件用了将近5分钟。–upgrade安装时强制替换老版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade --target=D:\Python27_13\Lib\site-packages D:\numpy-1.16.3-cp36-cp36m-win32.whl</span><br><span class="line">python -m pip install --upgrade --target=D:\Python27_13\Lib\site-packages D:\opencv_python-4.1.0.25-cp36-cp36m-win32.whl</span><br><span class="line">python -m pip install --upgrade --target=D:\Python27_13\Lib\site-packages D:\matplotlib-3.0.3-cp36-cp36m-win32.whl</span><br></pre></td></tr></table></figure></p><p>环境配置成功</p><h2 id="显示保存图片"><a href="#显示保存图片" class="headerlink" title="显示保存图片"></a>显示保存图片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python34\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#显示保存图片</span></span><br><span class="line"><span class="keyword">import</span> cv2   </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib  <span class="comment"># python -m pip install matplotlib-3.0.3-cp36-cp36m-win32.whl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print("cv2版本"+cv2.__version__)</span></span><br><span class="line"><span class="comment">#print(np.version.version)</span></span><br><span class="line"><span class="comment">#print(matplotlib.__version__)</span></span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">img=cv2.imread(<span class="string">'arterialImg.png'</span>,cv2.IMREAD_GRAYSCALE)  </span><br><span class="line">img2=cv2.imread(<span class="string">'arterialImg.png'</span>,cv2.IMREAD_COLOR)  </span><br><span class="line"><span class="comment">#cv2.IMREAD_COLOR 彩色模式忽略透明度，cv2.IMREAD_GRAYSCALE 灰度模式</span></span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.imshow(<span class="string">'image2'</span>,img2)</span><br><span class="line">k=cv2.waitKey(<span class="number">0</span>) <span class="comment">#0毫秒内无限等待键盘输入，检测键是否按下</span></span><br><span class="line"><span class="keyword">if</span> k==<span class="number">27</span>:</span><br><span class="line">cv2.destroyAllWindows() <span class="comment">#ESC按下</span></span><br><span class="line"><span class="keyword">elif</span> k==ord(<span class="string">'s'</span>):</span><br><span class="line"><span class="comment">#print("保存图片")</span></span><br><span class="line"><span class="comment">#cv2.imwrite("mess.jpg",img)</span></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">cv2.destroyAllWindows() </span><br><span class="line">print(<span class="string">"结束"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用Matplotlib"><a href="#使用Matplotlib" class="headerlink" title="使用Matplotlib"></a>使用Matplotlib</h2><p>Matplotlib是python的一个绘图库，包含各种各样的绘图方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python34\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#使用Matplotlib</span></span><br><span class="line"><span class="keyword">import</span> cv2   </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"></span><br><span class="line">font_set=FontProperties(fname=<span class="string">r"c:\windows\fonts\simsun.ttc"</span>,size=<span class="number">12</span>)</span><br><span class="line">img=cv2.imread(<span class="string">'arterialImg.png'</span>,cv2.IMREAD_COLOR)  </span><br><span class="line">plt.imshow(img,cmap=<span class="string">'gray'</span>,interpolation=<span class="string">'bicubic'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u'年份'</span>,fontproperties=font_set)</span><br><span class="line">plt.ylabel(<span class="string">u'产量'</span>,fontproperties=font_set)</span><br><span class="line">plt.legend(prop=font_set,loc=<span class="string">'best'</span>)</span><br><span class="line">plt.title(<span class="string">"裤子"</span>,fontproperties=font_set)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="使用摄像头捕获视频"><a href="#使用摄像头捕获视频" class="headerlink" title="使用摄像头捕获视频"></a>使用摄像头捕获视频</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python34\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#使用摄像头捕获视频</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2   </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap=cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">ret,frame=cap.read()</span><br><span class="line">gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">'frame'</span>,gray)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)&amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;cap.isOpened()可检查摄像头设备是否初始化，如果返回True则没问题，否则要使用cap.open()<br>&emsp;&emsp;cap.get(propid)可获取视频一些参数信息，propid于0–18之间,如cap.get(3)和cap.get(4)可查看每帧宽和高<br>&emsp;&emsp;cap.set(propid,value)可修改视频属性，如cap.set(3,320)将视频宽度设置为320</p><h2 id="从文件中播放视频"><a href="#从文件中播放视频" class="headerlink" title="从文件中播放视频"></a>从文件中播放视频</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#从文件中播放视频</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">"../JustTheWayYouAre.mp4"</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment">#获取一帧图像</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment">#显示一帧图像</span></span><br><span class="line">    cv2.imshow(<span class="string">"capture"</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows() </span><br><span class="line"><span class="comment">#cv2.waitKey(25) 代表一帧25毫秒，这可以控制播放速度</span></span><br></pre></td></tr></table></figure><h2 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h2><p>&emsp;&emsp;OpenCV是计算机视觉库，可以把图片序列保存成视频(也是基于vfw和ffmpeg的)，但它本身并不是视频编码解码器，只支持avi的格式，而且生成的视频文件不能大于2GB，不能添加音频。如果想突破这些限制，还是得用ffMpeg。<br>&emsp;&emsp;捕获视频，并对每一帧进行加工后想要保存这个视频。<br>&emsp;&emsp;保存视频需要创建一个VideoWriter对象，确定输出文件的名字，指定FourCC编码，帧大小，播放频率和isColor标签。<br>&emsp;&emsp;有一个比较坑的地方，opencv修改后保存视频的帧大小宽高必须与原始视频保持一致才行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#打开一个本地视频，将每帧图像翻转后保存为另一个视频。</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">"../JustTheWayYouAre.mp4"</span>)</span><br><span class="line">frame_width = int(cap.get(<span class="number">3</span>))</span><br><span class="line">frame_height = int(cap.get(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#需要去http://www.fourcc.org/downloads/divx-912-7/start下载DIVX编码器</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">out = cv2.VideoWriter(<span class="string">'output.avi'</span>,fourcc, <span class="number">20.0</span>, (frame_width,frame_height))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">ret, frame = cap.read()</span><br><span class="line"><span class="keyword">if</span> ret==<span class="literal">True</span>:</span><br><span class="line">frame = cv2.flip(frame,<span class="number">0</span>)</span><br><span class="line">out.write(frame)</span><br><span class="line">cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="线-矩形-圆-椭圆-多边形-添加文字"><a href="#线-矩形-圆-椭圆-多边形-添加文字" class="headerlink" title="线,矩形,圆,椭圆,多边形,添加文字"></a>线,矩形,圆,椭圆,多边形,添加文字</h2><p>需要使用这些函数cv2.line(),cv2.rectangle(),cv2.circle(),cv2.ellipse(),cv2.putText()<br>上面函数都需要设置的共同参数：</p><ul><li>img：想要绘制图形的那张图</li><li>color：形状的颜色，rgb需要传入一个元组，灰度图只需传入灰度值。</li><li>thickness：线条粗细。默认为1。如果一个闭合图形设置为-1，该图形被填充。 </li><li>linetype：线条类型，8连通、抗锯齿等。(并不是指线型是实线、虚线还是点画线，这个参数实际用途是改变线的产生算法)，默认8连通，cv2.LINE_AA为抗锯齿，使线条看起来平滑。</li></ul><p>&emsp;&emsp;画线，需要指定线的起点和终点。<br>&emsp;&emsp;画矩形，需要指定左上角顶点和右下角顶点。<br>&emsp;&emsp;画圆，需要指定圆形中心点坐标和半径大小。<br>&emsp;&emsp;画椭圆，需要指定椭圆的中心点坐标、长轴和短轴长度、椭圆沿逆时针旋转的角度，椭圆弧沿顺时针方向起始角度和结束角度(0-360代表整个椭圆)。<br>&emsp;&emsp;画多边形，需要指定每个顶点的坐标。cv2.polylines()可用来画很多线，只需要将要画的线放在一个列表里传给函数即可。每条线被独立绘制，这比cv2.line()一条一条绘制要快一些。<br>&emsp;&emsp;在图片上添加文字，需要设置下列参数：要绘制文字、要绘制的位置、字体类型(通过查看cv2.putText()的文档找到支持字体)、字体的大小、文字的一般属性，如颜色、粗细、线条类型等，为美观一般linetype=cv2.LINE_AA。<br>&emsp;&emsp;所有绘图函数返回值都是None，所以img1=cv2.line(img,(0,0),(511,511),(255,0,0),5)是错误的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#线,矩形,圆,椭圆,多边形,添加文字</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line"><span class="comment">#画线</span></span><br><span class="line">cv2.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line"><span class="comment">#图片上添加文字</span></span><br><span class="line">font=cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv2.putText(img,<span class="string">'OpenCV'</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"><span class="comment">#画矩形</span></span><br><span class="line">cv2.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line"><span class="comment">#画圆</span></span><br><span class="line">cv2.circle(img,(<span class="number">447</span>,<span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line"><span class="comment">#画椭圆</span></span><br><span class="line">cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">30</span>,<span class="number">0</span>,<span class="number">360</span>,<span class="number">255</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#画多边形</span></span><br><span class="line">pts=np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">pts=pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)<span class="comment">#如果去掉中括号，只是画四个点。如果第三个参数为False，多边形不闭合首尾不相连</span></span><br><span class="line">，</span><br><span class="line">cv2.imshow(<span class="string">'opencv'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="鼠标回调事件"><a href="#鼠标回调事件" class="headerlink" title="鼠标回调事件"></a>鼠标回调事件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#鼠标回调事件</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span><br><span class="line"><span class="keyword">if</span> event==cv2.EVENT_LBUTTONDBLCLK:</span><br><span class="line">cv2.circle(img,(x,y),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>)&amp;<span class="number">0xFF</span>==<span class="number">27</span>: <span class="comment"># esc退出</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>按下拖拽鼠标，mode为true绘制矩形，为False绘制曲线，按M切换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">drawing=<span class="literal">False</span></span><br><span class="line">mode=<span class="literal">True</span></span><br><span class="line">ix,iy=<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span><br><span class="line"><span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line"><span class="keyword">if</span> event==cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">drawing=<span class="literal">True</span></span><br><span class="line">ix,iy=x,y</span><br><span class="line"><span class="keyword">elif</span> event==cv2.EVENT_MOUSEMOVE <span class="keyword">and</span> flags==cv2.EVENT_FLAG_LBUTTON:</span><br><span class="line"><span class="keyword">if</span> drawing==<span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> mode==<span class="literal">True</span>:</span><br><span class="line">cv2.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">cv2.circle(img,(x,y),<span class="number">3</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">elif</span> event==cv2.EVENT_LBUTTONUP:</span><br><span class="line">drawing==<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">k=cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span></span><br><span class="line"><span class="keyword">if</span> k==ord(<span class="string">'m'</span>):</span><br><span class="line">mode=<span class="keyword">not</span> mode</span><br><span class="line"><span class="keyword">elif</span> cv2.waitKey(<span class="number">20</span>)&amp;<span class="number">0xFF</span>==<span class="number">27</span>: <span class="comment"># esc退出</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h2><p>&emsp;&emsp;通过调节滑动条设定画板颜色。<br>&emsp;&emsp;cv2.getTrackbarPos()的参数分别为滑动条名字、滑动条被放置窗口的名字、滑动条默认位置、滑动条最大值、回调函数。每次滑动条滑动都会调用回调函数，回调函数的默认参数就是滑动条的位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">drawing=<span class="literal">False</span></span><br><span class="line">mode=<span class="literal">True</span></span><br><span class="line">ix,iy=<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"></span><br><span class="line">switch=<span class="string">'0:off\n1:on'</span></span><br><span class="line">cv2.createTrackbar(switch,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">k=cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span></span><br><span class="line"><span class="keyword">if</span> k==<span class="number">27</span>:        <span class="comment">#esc退出</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">r=cv2.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span><br><span class="line">g=cv2.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">b=cv2.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">s=cv2.getTrackbarPos(switch,<span class="string">'image'</span>)</span><br><span class="line"><span class="keyword">if</span> s==<span class="number">0</span>:</span><br><span class="line">img[:]=<span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">img[:]=[b,g,r]</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="获取并修改像素值"><a href="#获取并修改像素值" class="headerlink" title="获取并修改像素值"></a>获取并修改像素值</h2><p>&emsp;&emsp;cv2.imread()读取的图片默认情况下为彩图（三通道图片），所以，在定位到对应(x,y)像素点上的时候，得到的就是三维向量。numpy的操作基于性能考虑，能用矩阵运算就不用循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">"psb.jpg"</span>)</span><br><span class="line">print(img.shape) <span class="comment">#返回图像的属性，包括(行，列，通道数)</span></span><br><span class="line">print(img.size) <span class="comment">#图像的像素数目</span></span><br><span class="line">print(img.dtype) <span class="comment">#图像的数据类型</span></span><br><span class="line">p=img[<span class="number">100</span>,<span class="number">100</span>] <span class="comment">#获取某点属性</span></span><br><span class="line">print(p)</span><br><span class="line">px=img.item(<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>)  </span><br><span class="line">py=img.item(<span class="number">100</span>,<span class="number">100</span>,<span class="number">1</span>)  </span><br><span class="line">pz=img.item(<span class="number">100</span>,<span class="number">100</span>,<span class="number">2</span>)  </span><br><span class="line">print(str(px)+<span class="string">' '</span>+str(py)+<span class="string">" "</span>+str(pz)) <span class="comment">#分别获取某点的rgb各值 </span></span><br><span class="line">img.itemset((<span class="number">100</span>,<span class="number">100</span>,<span class="number">2</span>),<span class="number">138</span>) <span class="comment">#设置某分量的值</span></span><br><span class="line">pz=img.item(<span class="number">100</span>,<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line">print(str(pz))</span><br></pre></td></tr></table></figure></p><h2 id="图像ROI"><a href="#图像ROI" class="headerlink" title="图像ROI"></a>图像ROI</h2><p>&emsp;&emsp;ROI全称Region Of Internet，感兴趣的区域，就是从图像中选择一个图像区域。<br>&emsp;&emsp;下面代码将一块感兴趣的区域，复制到了另一个地方，或者单独提取出来。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">"psb.jpg"</span>)</span><br><span class="line"></span><br><span class="line">source=img[<span class="number">280</span>:<span class="number">340</span>,<span class="number">330</span>:<span class="number">390</span>]</span><br><span class="line">img[<span class="number">273</span>:<span class="number">333</span>,<span class="number">100</span>:<span class="number">160</span>]=source <span class="comment">#感兴趣的区域复制到了另一个地方</span></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.imshow(<span class="string">'dandu'</span>,source) <span class="comment">#感兴趣的区域单独提取出来</span></span><br><span class="line">k=cv2.waitKey(<span class="number">0</span>) <span class="comment">#0毫秒内无限等待键盘输入，检测键是否按下</span></span><br><span class="line"><span class="keyword">if</span> k==<span class="number">27</span>:</span><br><span class="line">cv2.destroyAllWindows() <span class="comment">#ESC按下</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="拆分通道及合并通道"><a href="#拆分通道及合并通道" class="headerlink" title="拆分通道及合并通道"></a>拆分通道及合并通道</h2><p>v2.split函数分离得到各个通道的灰度值(单通道图像)。<br>cv2.merge函数是合并单通道成多通道（不能合并多个多通道图像）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">"psb.jpg"</span>)</span><br><span class="line">b,g,r=cv2.split(img)</span><br><span class="line">print(<span class="string">"img shape "</span>+str(img.shape))</span><br><span class="line">print(<span class="string">"r shape "</span>+str(r.shape))</span><br><span class="line">cv2.imshow(<span class="string">'r '</span>,r)</span><br><span class="line">cv2.imshow(<span class="string">'g '</span>,g)</span><br><span class="line">cv2.imshow(<span class="string">'b '</span>,b)</span><br><span class="line"><span class="comment">#生成一个值为0的单通道数组</span></span><br><span class="line">zeros = np.zeros(img.shape[:<span class="number">2</span>], dtype = <span class="string">"uint8"</span>)</span><br><span class="line"><span class="comment"># 分别扩展B、G、R成为三通道。另外两个通道用上面的值为0的数组填充</span></span><br><span class="line">cv2.imshow(<span class="string">"Blue"</span>, cv2.merge([b, zeros, zeros]))</span><br><span class="line">cv2.imshow(<span class="string">"Green"</span>, cv2.merge([zeros, g, zeros]))</span><br><span class="line">cv2.imshow(<span class="string">"Red"</span>, cv2.merge([zeros, zeros, r]))</span><br><span class="line">img[:,:,<span class="number">2</span>]=<span class="number">0</span><span class="comment">#所有像素的红通道值为0  BGR</span></span><br><span class="line">cv2.imshow(<span class="string">"Blue+Green"</span>, img)</span><br><span class="line">img[:,:,<span class="number">1</span>]=<span class="number">0</span><span class="comment">#所有像素的绿通道值为0  前两个选所有像素，最后一个选通道</span></span><br><span class="line">img[:,:,<span class="number">0</span>]=<span class="number">0</span><span class="comment">#所有像素的蓝通道值为0  </span></span><br><span class="line">k=cv2.waitKey(<span class="number">0</span>)  </span><br><span class="line"><span class="keyword">if</span> k==<span class="number">27</span>:</span><br><span class="line">cv2.destroyAllWindows() <span class="comment">#ESC按下</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h2><p>使用cv2.add()将两幅图像进行加法运算，也可以直接使用numpy，res=img1+img2.两幅图像的大小，类型必须一致，或者第二个图像可以是一个简单的标量值。<br>openCV的加法是一种饱和操作，而numpy的加法是一种模操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">x=np.uint8([<span class="number">250</span>])</span><br><span class="line">y=np.uint8([<span class="number">10</span>])</span><br><span class="line">print(cv2.add(x,y))<span class="comment">#250+10=260&gt;=255</span></span><br><span class="line"><span class="comment">#结果为[[255]]</span></span><br><span class="line"><span class="keyword">print</span> (x+y)<span class="comment">#250+10=260%255=4</span></span><br><span class="line"><span class="comment">#结果为[4]</span></span><br></pre></td></tr></table></figure></p><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>这也是加法，不同的是两幅图像的权重不同，这会给人一种混合或者透明的感觉。图像混合的计算公式如下：<br>g(x) = (1−α)f<sub>0</sub>(x)+αf<sub>1</sub>(x)<br>通过修改α的值（0~1）,可以实现很酷的混合。<br>例：将两幅图像混合，第一幅权重为0.7.第二幅权重为0.3。函数cv2.addWeighed()可以按下面的公式对图片进行混合。<br>dst = α·img1 + β·img2+γ   这里γ的取值为0.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">img1=cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">img2=cv2.imread(<span class="string">'psb3.jpg'</span>)</span><br><span class="line"></span><br><span class="line">dst = cv2.addWeighted(img1,<span class="number">0.7</span>,img2,<span class="number">0.3</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>,dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">img1 = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">'psb3.jpg'</span>)</span><br><span class="line"><span class="comment">#创建一个黑色背景的窗口</span></span><br><span class="line">img = np.zeros((<span class="number">400</span>,<span class="number">400</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"> </span><br><span class="line">cv2.createTrackbar(<span class="string">'a'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">100</span>,nothing)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    k = cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">    r = cv2.getTrackbarPos(<span class="string">'a'</span>,<span class="string">'image'</span>)</span><br><span class="line">    r=float(r)/<span class="number">100.0</span></span><br><span class="line"> </span><br><span class="line">    img=cv2.addWeighted(img1,r,img2,<span class="number">1.0</span>-r,<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="阈值二值化和位运算"><a href="#阈值二值化和位运算" class="headerlink" title="阈值二值化和位运算"></a>阈值二值化和位运算</h2><p>&emsp;&emsp;图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。<br>&emsp;&emsp;一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。<br>&emsp;&emsp;位运算操作有and, or, not, xor。在提取部分图像选择非矩形区域roi时，位运算操作十分有用。<br>&emsp;&emsp;把opencv的标志放到另外一副图像上，如果使用加法，颜色会改变，如果使用混合，会变成透明，如果是矩形区域，可以使用roi方法，不是矩形时，用位运算实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">baidu_logo = cv2.imread(<span class="string">'baidu.png'</span>)</span><br><span class="line">target_img=cv2.imread(<span class="string">'target.jpg'</span>)</span><br><span class="line"><span class="comment">#图片相加需要有相同的宽和高，所以先构建一个新的图片baidu_resize，大小和目的图片相同</span></span><br><span class="line">baidu_resize  = np.ones(target_img.shape,np.uint8)</span><br><span class="line">baidu_resize =baidu_resize *<span class="number">255</span> <span class="comment"># 得到白色背景</span></span><br><span class="line"><span class="comment">#baidu_resize =baidu_resize *0 # 得到黑色色背景</span></span><br><span class="line"><span class="comment">#把baidu_logo图像放入生成的指定长宽大小的图像里</span></span><br><span class="line">baidu_resize[<span class="number">0</span>:baidu_logo.shape[<span class="number">0</span>], <span class="number">0</span>:baidu_logo.shape[<span class="number">1</span>]] = baidu_logo</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到灰度图</span></span><br><span class="line">baidu_logo_gray = cv2.cvtColor(baidu_resize, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment">#阈值二值化，灰度值大于200的像素点位置赋值255，其他像素点位置赋值0</span></span><br><span class="line">ret, mask = cv2.threshold(baidu_logo_gray, <span class="number">200</span>, <span class="number">255</span>, cv2.THRESH_BINARY) </span><br><span class="line"><span class="comment">#取反操作，mask中255的像素点值变为0， 值为0的像素点新值为255</span></span><br><span class="line">mask_inv = cv2.bitwise_not(mask)  </span><br><span class="line"><span class="comment">#对图像应用mask</span></span><br><span class="line">baidu_logo_fg = cv2.bitwise_and(baidu_resize, baidu_resize, mask = mask_inv)</span><br><span class="line">target_img_bg = cv2.bitwise_and(target_img, target_img, mask = mask)</span><br><span class="line"><span class="comment">#图像相加融合，得到最终结果</span></span><br><span class="line">added_img = cv2.add(baidu_logo_fg, target_img_bg)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'final'</span>,added_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="图像的运算"><a href="#图像的运算" class="headerlink" title="图像的运算"></a>图像的运算</h2><p>&emsp;&emsp;图像的基本运算有很多种，比如两幅图像可以相加、相减、相乘、相除、位运算、平方根、对数、绝对值等；图像也可以放大、缩小、旋转，还可以截取其中的一部分作为ROI（感兴趣区域）进行操作，各个颜色通道还可以分别提取及对各个颜色通道进行各种运算操作。总之，对于图像可以进行的基本运算非常的多。<br>&emsp;&emsp;基础数学运算应用于图像像素处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(InputArray src1, InputArray src2, OutputArray dst,InputArray mask=noArray()</span>, <span class="keyword">int</span> dtype</span>=-<span class="number">1</span>);<span class="comment">//dst = src1 + src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtract</span><span class="params">(InputArray src1, InputArray src2, OutputArray dst,InputArray mask=noArray()</span>, <span class="keyword">int</span> dtype</span>=-<span class="number">1</span>);<span class="comment">//dst = src1 - src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(InputArray src1, InputArray src2,OutputArray dst, <span class="keyword">double</span> scale=<span class="number">1</span>, <span class="keyword">int</span> dtype=<span class="number">-1</span>)</span></span>;<span class="comment">//dst = scale*src1*src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(InputArray src1, InputArray src2, OutputArray dst,<span class="keyword">double</span> scale=<span class="number">1</span>, <span class="keyword">int</span> dtype=<span class="number">-1</span>)</span></span>;<span class="comment">//dst = scale*src1/src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">double</span> scale, InputArray src2,OutputArray dst, <span class="keyword">int</span> dtype=<span class="number">-1</span>)</span></span>;<span class="comment">//dst = scale/src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scaleAdd</span><span class="params">(InputArray src1, <span class="keyword">double</span> alpha, InputArray src2, OutputArray dst)</span></span>;<span class="comment">//dst = alpha*src1 + src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWeighted</span><span class="params">(InputArray src1, <span class="keyword">double</span> alpha, InputArray src2,<span class="keyword">double</span> beta, <span class="keyword">double</span> gamma, OutputArray dst, <span class="keyword">int</span> dtype=<span class="number">-1</span>)</span></span>;<span class="comment">//dst = alpha*src1 + beta*src2 + gamma</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqrt</span><span class="params">(InputArray src, OutputArray dst)</span></span>;<span class="comment">//计算每个矩阵元素的平方根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow</span><span class="params">(InputArray src, <span class="keyword">double</span> power, OutputArray dst)</span></span>;<span class="comment">//src的power次幂</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exp</span><span class="params">(InputArray src, OutputArray dst)</span></span>;<span class="comment">//dst = e**src（**表示指数的意思）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(InputArray src, OutputArray dst)</span></span>;<span class="comment">//dst = log(abs(src))</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;二进制数据的与、或、非、异或操作应用于图像像素处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitwise_and</span><span class="params">(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray()</span>)</span>;<span class="comment">//dst = src1 &amp; src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitwise_or</span><span class="params">(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray()</span>)</span>;<span class="comment">//dst = src1 | src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitwise_xor</span><span class="params">(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray()</span>)</span>;<span class="comment">//dst = src1 ^ src2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitwise_not</span><span class="params">(InputArray src, OutputArray dst,InputArray mask=noArray()</span>)</span>;<span class="comment">//dst = ~src</span></span><br></pre></td></tr></table></figure></p><h2 id="使用OpenCV检测程序效率"><a href="#使用OpenCV检测程序效率" class="headerlink" title="使用OpenCV检测程序效率"></a>使用OpenCV检测程序效率</h2><p>cv2.getTickCount函数返回从参考点到这个函数被执行的时钟数。在一个函数执行前后都调用它，可以得到这个函数的执行时间。<br>cv2.getTickFrequency返回时钟频率，或者说每秒钟的时钟数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="comment">#窗口大小不同（5,7,9）的核函数来做中值滤波，查看一个函数运行了多少秒</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">img1 = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">e1 = cv2.getTickCount() <span class="comment">#开始计时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">49</span>,<span class="number">2</span>):</span><br><span class="line">img1 = cv2.medianBlur(img1,i)</span><br><span class="line"></span><br><span class="line">e2 = cv2.getTickCount() <span class="comment">#结束计时</span></span><br><span class="line">time = (e2-e1)/cv2.getTickFrequency()</span><br><span class="line">print(time) <span class="comment">#中间过程耗时</span></span><br></pre></td></tr></table></figure><h2 id="OpenCV的默认优化"><a href="#OpenCV的默认优化" class="headerlink" title="OpenCV的默认优化"></a>OpenCV的默认优化</h2><p>cv2.useOptimized()来查看优化是否被开启，cv2.setUesOptimized()来开启优化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cv2.setUseOptimized(<span class="literal">True</span>)</span><br><span class="line">print(cv2.useOptimized()) </span><br><span class="line">img1 = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">49</span>,<span class="number">2</span>):</span><br><span class="line">img1 = cv2.medianBlur(img1,i)</span><br><span class="line"></span><br><span class="line">e2 = cv2.getTickCount()</span><br><span class="line">time = (e2-e1)/cv2.getTickFrequency()</span><br><span class="line">print(<span class="string">"优化过的耗时："</span>+str(time))</span><br><span class="line"></span><br><span class="line">cv2.setUseOptimized(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">'psb.jpg'</span>)</span><br><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">49</span>,<span class="number">2</span>):</span><br><span class="line">img1 = cv2.medianBlur(img1,i)</span><br><span class="line"></span><br><span class="line">e2 = cv2.getTickCount()</span><br><span class="line">time = (e2-e1)/cv2.getTickFrequency()</span><br><span class="line">print(<span class="string">"取消优化的耗时："</span>+str(time))</span><br><span class="line">cv2.setUseOptimized(<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#取消优化后的耗时更短。。。</span></span><br></pre></td></tr></table></figure></p><h2 id="转换颜色空间"><a href="#转换颜色空间" class="headerlink" title="转换颜色空间"></a>转换颜色空间</h2><p>&emsp;&emsp;在OpenCV中有超过150种进行颜色空间转换的方法。但是你以后就会发现我们经常用到的也就两种：BGR↔Gray 和 BGR↔HSV。<br>&emsp;&emsp;我们用到的函数是cv2.cvtColor(input_imageﬂag)，其中ﬂag就是转换类型。<br>&emsp;&emsp;对于BGR↔Gray的转换，我们使用的ﬂag就是cv2.COLOR_BGR2GRAY。<br>&emsp;&emsp;同样对于BGR↔HSV的转换我们用的ﬂag就是cv2.COLOR_BGR2HSV。<br>&emsp;&emsp;得到所有可用的颜色空间flag<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2):</span><br><span class="line"><span class="keyword">if</span> i.startswith(<span class="string">'COLOR_'</span>):</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在OpenCV的HSV格式中，H（色彩/色度）的取值范围是[0，179]，S（饱和度）的取值范围[0，255]，V（亮度）的取值范围[0，255]。但是不同的软件使用的值可能不同。所以当你拿OpenCV的HSV值与其他软件的HSV值对比时，一定要记得归一化。</p><h2 id="物体跟踪"><a href="#物体跟踪" class="headerlink" title="物体跟踪"></a>物体跟踪</h2><p>现在我们知怎样将一幅图像从BGR换到HSV了，我们可以利用这点来提取带有某个特定色的物体。在HSV颜色空间中要比在BGR空间中更容易表示一个特定颜色。在我们的程序中，我们提取的是一个蓝色的物体。以下就是我们做的几步：</p><ul><li>从视频中获取每一帧图像</li><li>将图像转换到HSV空间</li><li>设置HSV阈值到蓝色范围</li><li>获取蓝色物体<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:\Python27_13\python.exe</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.6.8</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment">#获取每一帧</span></span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    <span class="comment">#转换到HSV</span></span><br><span class="line">    hsv = cv2.cvtColor(frame,cv2.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment">#设定蓝色的阀值</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment">#根据阀值构建掩模</span></span><br><span class="line">    mask = cv2.inRange(hsv,lower_blue,upper_blue)</span><br><span class="line">    <span class="comment">#对原图和掩模进行位运算</span></span><br><span class="line">    res = cv2.bitwise_and(frame,frame,mask=mask)</span><br><span class="line">    <span class="comment">#显示图像</span></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">    cv2.imshow(<span class="string">'mask'</span>,mask)</span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>,res)</span><br><span class="line">    k = cv2.waitKey(<span class="number">5</span>)&amp;<span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#关闭窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenCV的Python实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown基础语法</title>
      <link href="/2019/05/15/firstBlog/"/>
      <url>/2019/05/15/firstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown支持6种级别的标题，对应html标签<strong>h1~h6</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#      h1</span><br><span class="line">##     h2</span><br><span class="line">###    h3</span><br><span class="line">####   h4</span><br><span class="line">#####  h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure></p><h2 id="段落及区块引用"><a href="#段落及区块引用" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h2><p>Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。</p><p>另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这段文字将被高亮强调显示</span><br></pre></td></tr></table></figure></p><blockquote><p>这段文字将被高亮强调显示   </p></blockquote><h2 id="插入链接或图片"><a href="#插入链接或图片" class="headerlink" title="插入链接或图片"></a>插入链接或图片</h2><p>引用图片和链接的唯一区别就是在最前方添加一个感叹号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接链接：&lt;http://www.baidu.com&gt;</span><br><span class="line">[点击跳转至百度](http://www.baidu.com)</span><br><span class="line">![图片](https://box.bdimg.com/static/fisp_static/common/img/searchbox/logo_news_276_88_1f9876a.png)</span><br></pre></td></tr></table></figure></p><p>直接链接：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br><a href="http://www.baidu.com" target="_blank" rel="noopener">点击跳转至百度</a></p><p><img src="https://box.bdimg.com/static/fisp_static/common/img/searchbox/logo_news_276_88_1f9876a.png" alt="图片"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown支持有序列表和无序列表两种形式：<br>无序列表使用*或+或-标识<br>有序列表使用数字标识 例如1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 黄瓜</span><br><span class="line">* 玉米</span><br><span class="line">* 茄子</span><br><span class="line"></span><br><span class="line">+ 黄瓜</span><br><span class="line">+ 玉米</span><br><span class="line">+ 茄子</span><br><span class="line"></span><br><span class="line">- 黄瓜</span><br><span class="line">- 玉米</span><br><span class="line">- 茄子</span><br><span class="line"></span><br><span class="line">1. 黄瓜</span><br><span class="line">2. 玉米</span><br><span class="line">3. 茄子</span><br></pre></td></tr></table></figure></p><ul><li>黄瓜</li><li>玉米</li><li>茄子</li></ul><ul><li>黄瓜</li><li>玉米</li><li>茄子</li></ul><ul><li>黄瓜</li><li>玉米</li><li>茄子</li></ul><ol><li>黄瓜</li><li>玉米</li><li>茄子</li></ol><p>如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格</p><p>如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*    段落一</span><br><span class="line"></span><br><span class="line">     小段一</span><br><span class="line">*    段落二</span><br><span class="line"></span><br><span class="line">     小段二</span><br><span class="line">* 段落一</span><br><span class="line">    &gt; 区块标记一</span><br><span class="line">* 段落二</span><br><span class="line">    &gt; 区块标记二</span><br></pre></td></tr></table></figure></p><ul><li><p>段落一</p><p>小段一</p></li><li><p>段落二</p><p>小段二</p></li><li>段落一<blockquote><p>区块标记一</p></blockquote></li><li>段落二<blockquote><p>区块标记二  </p></blockquote></li></ul><p>记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr><hr><h2 id="对部分文字强调"><a href="#对部分文字强调" class="headerlink" title="对部分文字强调"></a>对部分文字强调</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*这里是斜体*</span><br><span class="line">_这里是斜体_</span><br><span class="line"></span><br><span class="line">**这里是加粗**</span><br><span class="line">__这里是加粗__</span><br><span class="line"></span><br><span class="line">上标：O&lt;sub&gt;2&lt;/sub&gt;，下标：3&lt;sup&gt;2&lt;/sup&gt;</span><br><span class="line">简称或缩写:</span><br><span class="line">The &lt;abbr title=&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;.</span><br></pre></td></tr></table></figure><p><em>这里是斜体</em><br><em>这里是斜体</em></p><p><strong>这里是加粗</strong><br><strong>这里是加粗</strong></p><p>上标：O<sub>2</sub>，下标：3<sup>2</sup><br>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>三个短斜杠左右的冒号用于控制对齐方式<br>只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表头|条目一|条目二</span><br><span class="line">:---:|:---:|:---:</span><br><span class="line">项目|项目一|项目二</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">表头</th><th style="text-align:center">条目一</th><th style="text-align:center">条目二</th></tr></thead><tbody><tr><td style="text-align:center">项目</td><td style="text-align:center">项目一</td><td style="text-align:center">项目二</td></tr></tbody></table><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>使用反斜杠\插入语法中用到的特殊符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">\\   反斜线</span><br><span class="line">\`   反引号</span><br><span class="line">\*   星号</span><br><span class="line">\_   底线</span><br><span class="line">\&#123; \&#125;  花括号</span><br><span class="line">\[ \]  方括号</span><br><span class="line">\( \)  括弧</span><br><span class="line">\#   井字号</span><br><span class="line">\+   加号</span><br><span class="line">\-   减号</span><br><span class="line">\.   英文句点</span><br><span class="line">\!   惊叹号</span><br><span class="line"></span><br><span class="line">&amp;copy; &amp;  &amp;uml; &amp;trade; &amp;iexcl; &amp;pound;</span><br><span class="line">&amp;amp; &amp;lt; &amp;gt; &amp;yen; &amp;euro; &amp;reg; &amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot;</span><br><span class="line"></span><br><span class="line">X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14;  &amp;times;  &amp;divide;   &amp;raquo;</span><br></pre></td></tr></table></figure></p><p>\   反斜线<br>`   反引号<br>*   星号<br>_   底线<br>{ }  花括号<br>[ ]  方括号<br>( )  括弧<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   惊叹号</p><p>&copy; &amp;  &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14;  &times;  &divide;   &raquo;</p><h2 id="文字上色"><a href="#文字上色" class="headerlink" title="文字上色"></a>文字上色</h2><p>Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=&apos;#ff0000&apos;&gt;红色&lt;/font&gt;</span><br></pre></td></tr></table></figure></p><font color="#ff0000">红色</font><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```javascript</span><br><span class="line">function test() &#123;</span><br><span class="line">console.log(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">            ul&#123;list-style: none;&#125;          </span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
