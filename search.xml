<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经典排序算法学习]]></title>
    <url>%2F2019%2F08%2F20%2FAlgorithmicLearning%2F</url>
    <content type="text"><![CDATA[冒泡排序(Bubble Sort) 选择排序(Selection Sort)插入排序(Insertion Sort)希尔排序(Shell Sort)归并排序(Merge Sort)快速排序(Quick Sort)堆排序(Heap Sort)计数排序(Counting Sort)桶排序(Bucket Sort)基数排序(Radix Sort)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一个人做事情到多个人做事情]]></title>
    <url>%2F2019%2F06%2F03%2Fguanlixiaotuandui%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;从一个人做事情到多个人做事情,意味着很多转变： 从单人到多人协作的转变：单人时，沟通无关紧要，没有文档也问题不大，项目做的不好，自己可能加个班重构一下，但你让小伙伴重构还要做大量的说服工作。 从一段时间一个项目到多个项目并进的转变：有些项目人力不够要搁置，不同项目处于不同的阶段，不同的项目自己承担的角色不同技术管理到底管什么 技能大概分两种：谋略和理事。谋略重在想办法，理事重在做事情。但凡名士谋臣至少有一样特长，两者兼顾自然不世功勋唾手而来。 谋略：技术架构搭建、新技术演进选型等，解决该做什么和怎么做的问题。 理事：任务和人员协调、分配等，解决谁来做、哪件事先做的问题。 目的是把事情做好，管人只是一种方式而已，不要轻易尝试去改变一个人，哪怕你是为他好，哪怕改的是缺点对他也有好处。以代码规范为例： 最好的方式，通过技术手段去保证，不按照规范去做的代码没法提交成功。 次级好的方式，建立规范准则，要求大家去遵守。 最坏的方式，质问为什么不这么做。 如果不写代码就会心慌，说明你把太多精力花在理事上，把谋略给丢了。实际上， 技术架构满足不了业务需求的时候，是需要你(和架构师一起)拿出新的架构的； 组员讨论几个方案拿不定主意的时候，也是需要你去做决策的。这些都是需要你平时花时间去不断丰富和充实你的技术的。否则一定是一将无能累死三军。 不应该陷入与人沟通和处理杂事的漩涡中，而是应该抽时间出来保持自己的技术敏感度。管理者和普通员工在技术上的区别，在于和技术打交道的方式变了。普通员工是写代码，技术管理者应该是学习技术和思考架构。 能够发现问题。 能够提供解决问题的思路和方案，并能比较这些方案的优缺点。 能够做正确的技术决定。 能够用更优雅、简单、容易的方式来解决问题。 能够提高代码或软件的扩展性、重用性和可维护性。 能够用正确的方式管理团队(让正确的人做正确的事，提高团队效率，用最少的成本实现最有价值的需求)。 创新能力。12345678技术人员的成长粗略划分为四大阶段：新手：新手就是新手。。。(突破期)熟手：新手经过半年到一年的工作经验，如果能成功适应这份工作，基本就能有所突破，变成一个熟手。熟手的特点是，能对现成的工具充分利用，胜任大部分日常工作。在技术水平的表现上，他了解大部分的技术概念，但不一定理解真正的含义；在他的眼中，技术还无法自成体系，能理解到的知识架构还有所残缺。他解决问题所依靠的，更多是经验而非缜密的逻辑。(舒适期/瓶颈期/突破期)专家：某个领域拥有足够全面、系统而深入的知识储备，对于技术上的疑难杂症，有能力深入到足够的层次，指出问题的症结所在；另一方面，专家还应该能够完成对具体问题的抽象，拥有“造轮子”的能力。在专家的眼中，技术的黑盒子被打开，知识点也不再是孤立存在的，而是相互枝连，构成一个完整的逻辑系统。(舒适期/瓶颈期/突破期)宗师：这一级别的，整个世上也寥寥无几。他们是真正的开创者，能够引领一个技术时代。什么样的人才配得上“宗师”这个称呼呢？比如Dennis M. Ritchie（C语言和Unix之父），再比如Linus（Linux内核的发明人）。技术的成长阶段并没有一个上限。无论你处在哪个阶段，前面仍然存在无限的上升空间。 小伙伴如果主动性不高，其实是对分配给自己的任务负责。小队长是对项目负责，项目的成功与小伙伴干完自己具体任务之间有大量的规划、协调、踩石头过河的事，需要对项目结果负责的人去完成。 心态你必须要接受，本来你可以十分钟干完的事儿，别人要干两个小时。你设计的很有美感的代码被破坏殆尽。但该他负责的事情还是要他去做，否则他没有参与感，永远无法主动地做工作。很多事情你做了其实没有成长，但还是要带着别人一起做，帮助别人成长也是你工作的一部分。曾经的一个困惑：”我知道很多事儿要干，但我不知道精力投向哪里”。迷茫，就是对当前的处境没有成体系化的认识，要多人交流，整理，发现规律，指导实践。要兼容不同的人，有的很有想法但落地能力不够，有的想法较少但好在认真负责等，不以自己认为的优缺点去套别人。 做事与效能提升原则 Owner意识 认真负责是工作的底线。首先，要对我们交付的结果负责。项目中每一个设计文档、每一行代码都需要认真完成，要对它的质量负责。如果设计文档逻辑混乱，代码没有注释，测试时发现一堆Bug，影响的不仅仅是RD(研发:Research&amp;Design)的工程交付质量，还会对协同工作的RD、QA(质量保证:Quality&amp;Assurance)、PM(Project&amp;Management)等产生不好的影响。久而久之，团队的整体交付质量、工作效率也会逐步下降，甚至会导致团队成员之间产生不信任感。其次，我们要对开发的系统负责。系统的架构是否需要改进，接口文档是否完善，日志是否完整，数据库是否需要扩容，缓存空间够不够等等，这些都是需要落地的事情。作为系统Owner，请一定要认真履行。 积极主动是“Owner意识”更高一级的要求。RD每天要面对大量的工作，而且很多并不在计划内，这就需要具备一种积极主动的精神。例如我们每天可能会面对大量的技术咨询，如果客户提出的问题很长时间得不到回应的话，就会带来不好的客户体验。很多同学说忙于自己的工作没有时间处理，有同学觉得这件事不是很重要，也有很多同学是看到了，但是不知道怎么回答，更有甚者，看到了干脆装没看见。这些都是缺乏Owner意识的体现。正确的做法是积极主动地推动问题的解决，如果时间无法排开或者不知道如何解决，可以直接将问题反馈给能解决的同学。积极主动还可以表现在更多方面。比如很多同学会自发地梳理负责服务的现状，根据接口在性能方面暴露的问题提出改进意见并持续推动解决；也有同学在跨团队沟通中主动承担起主R的角色，积极发现问题、暴露问题，推动合作团队的进度，保证项目顺利推进。这些同学无一不是团队的中坚力量。所以，我们在做好自己份内工作的同时，也应该积极主动地投入到“份外”的工作中去。一分耕耘一分收获，不要给自己设限，努力成为一个更加优秀的人。 时间观念研发的效率是公司硬实力的体现。项目的按时交付是一项很重要的执行能力。按时交付的同学往往具备如下两个特质：做事有计划，工作分主次。Web端产品粗略的流程为：发现需求（产品经理）→功能需求确定（产品经理）→交互设计稿（交互设计师）→视觉设计稿（视觉设计师）→前端研发（前端工程师FE）→后端研发(后端工程师RD)→测试&amp;BUG修复（测试QA）→上线工作安排要有计划性。通常，RD在设计评审之后就能预估出精确的开发时间，进而再合理地安排开发、联调、测试计划。如果是项目负责人，那么就会涉及协调FE、QA、PM等多个工种的同学共同完成工作。凡事预则立，不预则废。在计划制定过程中，要尽可能把每一项拆细一点（至少到pd粒度）。事实证明，粒度越细，计划就越精准，实际开发时间与计划之间的误差就会越小。此外，务必要规定明确的可检查的产出，并在计划中设置一些关键的时间点进行核对。无数血淋淋的事实告诉我们，很多项目延期都是因为在一些关键交付点上双方存在分歧造成的。例如后台RD的接口文档计划在周五提供，FE认为是周五上午，而RD认为是周五下班前提交，无形中会给排期带来了1pd的误差。所以，我们要做到计划粒度足够细，关键时间点要可检查。工作安排要分清楚主次。我们每天要面对很多的事情，要学会分辨这些工作的主次。可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。很多项目无法按期交付的原因，都是因为执行人分不清主次。比如在开发中需要使用到ES，一些不熟悉ES的同学可能想系统性地学习一下这方面的知识，就会一头扎进ES的汪洋中。最后才发现，原本一天就能完成的工作被严重拖后。实际工作中，我们应当避免这种“本末倒置”的工作方式。在本例中，“系统性地学习ES”是一件重要但不紧急的事情。要学会分辨出这些干扰的工作项，保证重要紧急的事情能够按时交付。 以终为始在工作中，很多RD往往只是埋头走路，很少抬头看天。每次季度总结的时候，罗列了很多项目，付出很多努力。但是具体这些项目取得了哪些收益，对业务有哪些提升，却很难说出来。这就说明在工作中并没有遵守“以终为始”这一原则。此外，很多同学在做需求的过程中，对于目标与收益关注不够，系统上线之后，也没有持续地跟进使用效果。这一点在技术优化项目中体现得尤为明显。例如在一个接口性能优化的项目中，经过RD的努力优化，系统TP99缩短了60%，支持QPS提升了2倍。但是系统到底需要优化到什么程度呢？是不是缩短60%，提升2倍就能满足需求呢？在优化之前，很多同学常常忘记设置一个预设的目标（TP99小于多少，支持QPS大于多少）。我们必须清楚，优化一定是有原因的，比如预期某节假日流量会暴增或者某接口超时比例过高，如果不进行优化，系统可能会存在宕机风险。解决特定的问题才是技术优化的最终目的，所以要根据问题设定目标，再进行优化努力实现。 闭环思维你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。之前看过一句话：一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。这就是闭环思维的重要性。它强调的是一种即时反馈闭环，如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。例如在跨部门的沟通会议中，虽然各方达成了一致，会议发起者已经将最终的记录周知大家。但是，到这一步其实并没有完成真正的闭环，在落地执行过程中很可能还存在一些潜在的问题。例如，会议纪要是否经各方仔细核对并确认过？会议中明确的ToDo进展是什么？完成结果有没有Check的机制？如果这些没有做到的话，就会陷入”沟通-发现问题-再沟通-再发现问题”的恶性循环中。真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，ToDo要有验收。“闭环思维”还要求能够定期主动进行阶段性的反馈。刚参加工作时，我接了一个工期为两个月的项目。整个项目需要独自完成，自己每天按照计划，有条不紊地进行开发。大概过了两周之后，Leader询问项目进度，虽然我已经跟他说没问题。然而，Leader告诉我，因为我每天对着电脑也不说话，让他心里很没底。这时，我才意识到一个很重要的问题，我跟Leader之间存在信息不对称。从那以后，我就时不时得跟他汇报一下进度，哪怕就只有简短的一句话，也可以明显感觉，他对我的信心增加了很多。特别是我做Leader之后，对这种闭环反馈的理解，就更加深刻了。从Leader的角度看，其实只是想知道项目是否在正常推进，是否遇到问题需要他协助解决。 保持敬畏保持敬畏之心能够让我们少犯错误。在工作中存在各种各样的规范，例如代码规范、设计规范、上线规范等等。我们必须明白，这些规范的制定一定是基于某些客观原因的，它们都是历史上无数Case积累而来的经验。团队里的每一个成员都应该学习并严格遵守，这一点对于新人尤其重要。当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。以编码风格为例，很多同学往往习惯于自己之前的代码写作风格，在做新公司第一个项目时，也按照自己的习惯进行变量、包的命名等等。结果在代码Review过程中，被提了很多修改意见，不得不返工重写，得不偿失。如果能够保持敬畏之心，提前了解编码规范，这种问题完全可以避免。类似的问题，还包括对上线流程不了解，对回滚操作不熟悉，对SRE线上变更过程不了解等等。除了这些显而易见的规范，还有一些约定俗成的规则。个人建议是：如果有事情拿不准，不妨多问问其他同事，不要凭自己的感觉做事情。保持敬畏之心并不意味着要“因循守旧”。在我们充分了解这些规范和约定之后，如果觉得存在不妥之处，可以跟全组同学讨论，是否采纳新的建议，然后及时去更新迭代。其实，让规范与约定与时俱进，也是另一种形式的敬畏。 事不过二我们发现，很多RD都把时间花费在一些无休止的评审与问题讨论中，真正投入到实际开发中的时间反而很少。在实际工作场景中，我们经常会遇到一些不是很成熟的需求评审。这些需求文档，要么是背景与目标含糊不清，要么是产品方案描述不够细化，或者存在歧义。RD与PM被迫反复进行讨论，我曾经遇到过一个需求评审，进行了三次还被打回。同样的问题，在设计评审中也屡见不鲜。方案固然需要经过反复的讨论，但是如果迟迟不能达成一致，就会耗费很多RD与PM的宝贵时间，这就与提升研发效率的理念背道而驰。因此，我们团队规定：所有的需求评审最多两次。通过这种方式，倒逼利益相关方尽可能地做好需求与方案设计。评审会议组织前，尝试与所有相关人员达成一致，询问对方的意见，并进行有针对性的讨论，这样能够大大提升评审会议的效率和质量。如果在第一次评审中不通过，那么就只有一次机会进行复审。一旦两次不通过，就需要进行Casestudy。“事不过二”原则的另一层含义，是”同样的错误不能犯第二次“。每次故障之后，Casestudy都必须进行深刻的总结复盘，对故障原因进行5Why分析，给出明确可执行的To Do List。每次季度总结会，大家自我反省问题所在，在下个季度必须有所改善，不能再犯类似的错误。孔子云：“不迁怒，不贰过”，在错误中反思与成长，才能让我们成为更优秀的人。 设计优先架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。很多团队也有明文规定，开发周期在3pd以上的项目必须有设计文档，开发周期在5pd以上的项目必须有设计评审。在具体的执行过程中，由于各种原因，设计往往并不能达到预期的效果。究其原因，有的是因为项目周期紧，来不及设计得足够详细；有的是因为RD主观上认为项目比较简单，设计草草了事。无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。因此，无论什么时候都要记住“设计优先”这一原则。磨刀不误砍柴工，前期良好的设计，会给项目开发以及后期维护带来极大的收益。“设计优先”这一原则，要求写别人看得懂的设计。我们了解一个系统最直接的途径就是结合设计文档与代码。在实际工作中，很多同学的设计文档让大家看得一头雾水，通篇下来，看不出系统整体的设计思路。其实，设计的过程是一种智力上的创造，我们更希望它能成为个人与集体智慧的结晶。如何才能让我们的设计变得通俗易懂？我个人认为，设计应该尽量使用比较合理的逻辑，进而把设计中的一些点组织起来。比如可以使用从抽象到具体，由总到分的结构来组织材料。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。 产出与产能平衡伊索寓言中讲述了一个《生金蛋的鹅》的故事。产出好比“金蛋”，产能好比“会下金蛋的鹅”。“重蛋轻鹅”的人，最终可能连产蛋的资产都保不住；“重鹅轻蛋”的人，最终可能会被饿死。产出与产能必须平衡，才能达到真正的高效能。从系统的角度看，每一个系统都是通过持续不断地叠加功能来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。 善于提问“善于提问”，首先要勤于提问。求知欲源于好奇心，是人类的一种本能。在工作中要养成勤于提问的好习惯，不懂就问，不要因为自己一时懒惰或者碍于情面，就放弃提问的机会。当遇到不同的观点时，也要礼貌地问出来。波克定理告诉我们，只有在争辩中，才可能诞生最好的主意和最好的决定。在设计评审、代码评审这类体现集体智慧的活动中，遇到有问题的地方一定要提出来。我经常看到，很多同学评审全程一言不发，这就是浪费大家的时间。设计评审的目的，是让大家针对方案提出改进意见并达成一致，如果全程“打酱油”，那就失去了评审的意义。我们鼓励大家多提问，把自己内心的疑惑表达出来，然后通过交流的方式得到答案。“善于提问”，还要懂得如何提问。为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：批判性思维。批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。 空杯心态“满招损，谦受益”，“空杯心态”是最后一项原则。我觉得这也是一个人能够持续成长的前提。做技术的人，骨子里通常有股傲气，并且会随着资历、成绩的提升而不断增加。初入职场的小白，可能会非常谦虚，但是工作几年之后，专业技能逐步提升，可能还取得了一些小成就，人就会越来越自信。这时候，如果不能始终保持“空杯心态”，这种自信就会逐步演变为自满。自满的人，往往表现为工作中把别人的建议当成是批评，不接受任何反对意见，学习上也缺乏求知的动力，总是拿自己的长处去跟别人的短处做比较。其实每个人多少都会有一些自满，可怕的是不知道甚至不愿承认自满。保持“空杯心态”这一原则要求我们时刻进行自我检视与反省。 不同项目的不同角色不同的项目中，一个人可能呈现出不同的角色（可能是多个角色并存）： 需求/技术调研 唤醒高层、平级、小伙伴对项目的重视 项目设计 编码 进度推动/资源协调 推广 系统运营12345从一个程序员的角度来说，什么最让人安心？持续的技术进步。这里有几个认知问题:1.技术只是达成目标的一环，不同项目不同阶段 瓶颈不一样，作为一个小队长首要的是解决这些瓶颈2.随着代码能力的提高，一些项目的code无助于技术提高3.与技术的沟通方式变了，不仅是直接code，而是通过code review、项目设计 与技术“沟通” 作为开发，鼓励同时参与到其它角色中。作为小队长，因为精力有限，一旦决定了自己的角色，便要谨慎加入其它角色，尤其是短期内无法脱身的角色。一定要防止：同时推进多个项目，每天很忙但每个项目都进展不大的情况，因为这样会极大的削弱工作带来的“获得感”引发挫折感。被动应对的事情太多，主动规划的太少。这样你会很挫败，不仅是工作，人生也是如此。如果没有设计流程规范，大家习惯于会按照最简单的方案去实现。如果没有项目管理，大家习惯于去做最简单的/易做的/容易写周报的/依赖资源最少/推得动的事儿，而对紧急的、收尾的、杂碎的事儿无动于衷。进展不大的原因:123451.忙项目B时 被中断去解决项目A 的问题，负责项目越多，被中断的可能性越大，以至于完全无法开展新工作2.解答用户对系统的咨询3.“调度精力”带来的开销4.高层决心不确定，不是不做，但不肯花大力气做5.依赖方太多，你有空，别人没空 因此：1234561.尽量专人专职2.理清项目优先级，最好用图表的方式展示，适时搁置一些项目3.完备的文档，减少维护压力.4.两人或多人负责一个项目，使得有一人可以专心开发（另一人负责维护的事情）5.不能因为技术实现上图省事，来让上层业务方案来做妥协，进而产生让用户感觉困惑的操作。6.对自己小组的产出能力、工作负载要有一个认识，不要盲目拉活儿。 分阶段管理项目假设你同时负责几个项目，但不同的项目所处的状态是不一样的:12345策划阶段调研阶段设计阶段开发阶段维护阶段 策划和调研阶段，因为太模糊了，可能要独立完成。 设计阶段带着小伙伴一起做（业务架构图、类图、流程图、Swagger、数据库表设计等） 开发阶段，每天检查小伙伴的产出，确保没有跑偏即可。 维护阶段可以交给小伙伴，提取新的需求 进入新的循环。 如果所有阶段的所有事儿都需要你去做，那么一定有问题。如果一直如此，你可能不是纠结自己做什么，而是要换个人合作。当你有了一定的人力资源之后，你解决问题的工具集不能只是”一有问题自己上”。这个项目目前在什么阶段？最大的瓶颈在哪里？是否需要你直接参与？想好了再行动。 所处阶段 本周产出/进展 瓶颈/问题 切入点/办法 项目1 开发 下周转入测试 暂无 项目2 维护 无 暂无 code review 项目3 维护 明确xx为负责人 依赖资源不到位 组织各个大佬开会 项目4 调研 整理文档以备开会 需求不明 开会 项目5 开发 无 当前算法难以支持高并发 小组讨论 熟悉小伙伴 主动性 技术能力 认真负责 项目熟悉程度、兴趣程度 小伙伴1 小伙伴1 公司发展到一定阶段，能力强的员工容易离职，因为他们对公司内愚蠢的行为的容忍度不高，他们也容易找到好工作；能力差的员工倾向于留着不走，他们也不太好找工作，年头久了，他们就变中高层了。在湖畔大学第三届的第一课上，马云也讲到：小公司的成败在于你聘请什么样的人，大公司的成败在于你开除什么样的人。 小伙伴状态评估1234项目设计能力:技术选型，方案选型，一定的知识广度代码设计能力:优雅、“坏味道”比较少，易懂独立做事情有没有成长性，即自我超越的心思和动力 如何帮助小伙伴123451.直接指明工作中的问题2.找到跟他关系比较好的小伙伴（相对能力也强一点的），一则从他这边了解更多的信息， 二则让他们两个一起做事情。3.一个是准确判断小伙伴的状态，对一个人能力不停地试探，做的好就上探，做的不好就下探。你对他的期望和实际的工作不一致，他难受，你也难受。4.判断完毕后，可以推荐一些书籍， 限期读完，小组内做一个分享。5.对不同的事儿，不同的人，无所区别分析，是很大的偷懒。 每个小伙伴，进来的第一个项目最重要，你要进行观察，把他作为“客体”进行认知。性格、协作能力、设计能力、code能力（规范、以及优雅程度）。进而确定你们以后的相处模式1231.不用管(完全放心；或者小伙伴外向，主动沟通)2.定期汇报3.每日跟踪 衡量程序员的水平是对一个项目有没有一个全面的把控和实现。衡量一个架构师的水平，就是你的产出（包括但不限于表设计、接口定义、架构图等）是否对实施开发者水平要求太高。如果你不能将一个复杂的事情拆的很简单，以至于小伙伴有信心实施，那就说明你对问题的理解不够。 同时，不管他优秀也好，差一点也好，第一个项目想办法做成、做好。在这个过程中，将他的code 习惯等打上自己和公司的印记。沟通很重要，第一优先是质量，但这个比较难，需要你跟小伙伴在一个“思维”上。对于有些人来说，你教他防患于未然，不如等他自己踩坑。如果没有积极主动地心态，很多人要半年后才可以适应新公司的节奏。这个时候，带人耐心很重要。12345671.团队工作一定要有文档2.自己要对软件设计的本质有一个认识，先做到独自一人可以高质量的实施3.有了认识，才知道重点和难点，才能利用规律。当事情交给别人的做的时候，才知道如何把控。4.不要想着：把事情交给一个人，他就应该把事情做好，自己只要看结果就行而是想着这个事适不适合他干若是他干，哪些事儿他干不了。尤其是定好边界（表设计、前后端接口、架构图）等防止跑偏 整体环境的把握一个公司的发展有几个阶段1231.业务驱动：为用户带来价值，公司先活下去。2.技术和业务并重：技术问题暴露出来，不解决就无法进一步发展。3.技术驱动业务：具备极短事件内复制一个app、搞一个运营活动、为用户赋能、千人千面等。 具体显现在12具体体现在人员、精力的占比你觉得一件事需要好好搞搞，hr告诉你一个合适的候选人待遇要求很高时，才是考验你意志和决心的时候 每个阶段如何处理技术与业务的关系（以及是否进入下一阶段）是大佬的事情，但自己要认识到当前的局面 并做相应的调适123451.认识到某个技术当前在公司的定位、公司可能的投入，以有限的资源 去解决最痛的痛点2.技术要根据阶段取舍，你当前的项目也要根据阶段取舍。设计 ==&gt; 实现 ==&gt; 迭代 ==&gt; 搁置 ==&gt; 迭代，当前是什么状态？落后还是快于实际需要？自己要心里有数3.以第一线的观察 分析当前的问题/瓶颈，进行技术的宣传和说服工作，推动领导的相关决策4.对自己计划的制定、精力的分配 有一个判断5.无论大环境怎样，自己要保持激情，发现问题，解决问题，给自己信心，给身边人信心，把事情打开一个新局面，新气象。]]></content>
  </entry>
  <entry>
    <title><![CDATA[WebPack + Vue + element-ui]]></title>
    <url>%2F2019%2F05%2F20%2FWebPack-Vue-element-ui%2F</url>
    <content type="text"><![CDATA[实验目标:&emsp;&emsp;试验这种 WebPack+Vue+element-ui开发方式，实现前端模块按需加载。 Vue模板语法Vue使用了基于HTML的模版语法，允许开发者声明式地将DOM绑定至底层Vue实例的数据。Vue的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进DOM的系统。结合响应系统，在应用状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。 数据绑定最常见的形式就是使用{ {… } }（双大括号）的文本插值 123&lt;div id="vue_det"&gt; &lt;h1&gt;site : &#123;&#123;site&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 使用 v-html 指令用于输出html代码 123456789101112&lt;div id="app"&gt; &lt;div v-html="message"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: '&lt;h1&gt;教程&lt;/h1&gt;' &#125;&#125;)&lt;/script&gt; HTML 属性中的值应使用 v-bind 指令。以下实例判断 class1 的值，如果为 true 使用 class1 类的样式，否则不使用该类 12345678910111213141516&lt;div id="app"&gt; &lt;label for="r1"&gt;修改颜色&lt;/label&gt;&lt;input type="checkbox" v-model="use" id="r1"&gt; &lt;br&gt;&lt;br&gt; &lt;div v-bind:class="&#123;'class1': use&#125;"&gt; v-bind:class 指令 &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data:&#123; use: false &#125;&#125;);&lt;/script&gt; Vue都提供了完全的 JavaScript 表达式支持。 1234567891011121314151617&lt;div id="app"&gt; &#123;&#123;5+5&#125;&#125;&lt;br&gt; &#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;br&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125; &lt;div v-bind:id="'list-' + id"&gt;教程&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; ok: true, message: 'RUNOOB', id : 1 &#125;&#125;)&lt;/script&gt; 指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子，v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素。 123456789101112&lt;div id="app"&gt; &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; seen: true &#125;&#125;)&lt;/script&gt; 参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性如下例子， href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。 123456789101112&lt;div id="app"&gt; &lt;pre&gt;&lt;a v-bind:href="url"&gt;教程&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; url: 'http://www.baidu.com' &#125;&#125;)&lt;/script&gt; 另一个例子是 v-on 指令，它用于监听 DOM 事件1&lt;a v-on:click="doSomething"&gt; 在这里参数是监听的事件名。 修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() 1&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; 用户输入，在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定 12345678910111213&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'hello!' &#125;&#125;)&lt;/script&gt; v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。以下实例在用户点击按钮后对字符串进行反转操作：123456789101112131415161718&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt;反转字符串&lt;/button&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由”管道符”指示, 格式如下12345678910111213141516171819&lt;div id="app"&gt; &#123;&#123; message | capitalize &#125;&#125;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'runoob' &#125;, filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)&lt;/script&gt; 过滤器可以串联：1&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器是 JavaScript 函数，因此可以接受参数1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 这里，message 是第一个参数，字符串 ‘arg1’ 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。 Vue条件语句条件判断使用 v-if 指令,如下例子，在元素 和 template 中使用 v-if 指令：123456789101112131415161718&lt;div id="app"&gt; &lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt; &lt;template v-if="ok"&gt; &lt;h1&gt;菜鸟教程&lt;/h1&gt; &lt;p&gt;学的不仅是技术，更是梦想！&lt;/p&gt; &lt;p&gt;哈哈哈，打字辛苦啊！！！&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; seen: true, ok: true &#125;&#125;)&lt;/script&gt; 可以用 v-else 指令给 v-if 添加一个 “else” 块：如下例子，随机生成一个数字，判断是否大于0.5，然后输出对应信息1234567891011121314&lt;div id="app"&gt; &lt;div v-if="Math.random() &gt; 0.5"&gt; Sorry &lt;/div&gt; &lt;div v-else&gt; Not sorry &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; v-else-if 在 2.1.0 新增，顾名思义，用作 v-if 的 else-if 块。可以链式的多次使用,如下例子：判断 type 变量的值：1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;div v-if="type === 'A'"&gt; A &lt;/div&gt; &lt;div v-else-if="type === 'B'"&gt; B &lt;/div&gt; &lt;div v-else-if="type === 'C'"&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; type: 'C' &#125;&#125;)&lt;/script&gt; Vue循环语句循环使用 v-for 指令。v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。v-for 可以绑定数据到数组来渲染一个列表：1234567891011121314151617181920&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="site in sites"&gt; &#123;&#123; site.name &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; name: 'Runoob' &#125;, &#123; name: 'Google' &#125;, &#123; name: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; 模板中使用 v-for：123456&lt;ul&gt; &lt;template v-for="site in sites"&gt; &lt;li&gt;&#123;&#123; site.name &#125;&#125;&lt;/li&gt; &lt;li&gt;--------------&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for 可以通过一个对象的属性来迭代数据1234567891011121314151617181920&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="value in object"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; object: &#123; name: '菜鸟教程', url: 'http://www.baidu.com', slogan: '百度，百度！' &#125; &#125;&#125;)&lt;/script&gt; 你也可以提供第二个的参数为键名：1234567&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 第三个参数为索引：1234567&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; v-for 也可以循环整数1234567&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="n in 10"&gt; &#123;&#123; n &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; Vue计算属性计算属性在处理一些复杂逻辑时是很有用的。可以看下以下反转字符串的例子,如下例子，声明了一个计算属性 reversedMessage 。提供的函数将用作属性 vm.reversedMessage 的 getter 。vm.reversedMessage 依赖于 vm.message，在 vm.message 发生改变时，vm.reversedMessage 也会更新。1234567891011121314151617181920&lt;div id="app"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。12345methods: &#123; reversedMessage2: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; 可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。如下面代码，cnt 是独立于 vm 对象的变量。在使用 reversedMessage 这个计算属性的时候，第一次会执行代码，得到一个值，以后再使用 reversedMessage 这个计算属性，因为 vm 对象没有发生改变，于是界面渲染就直接用这个值，不再重复执行代码。而 reversedMessage2 没有这个缓存，只要用一次，函数代码就执行一次，于是每次返回值都不一样。123456789101112131415161718192021var cnt=1;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 cnt+=1; return cnt+this.message.split('').reverse().join('') &#125; &#125;, methods: &#123; reversedMessage2: function () &#123; cnt+=1; return cnt+this.message.split('').reverse().join('') &#125; &#125;&#125;) computed 属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：1234567891011121314151617181920212223242526var vm = new Vue(&#123; el: '#app', data: &#123; name: 'Google', url: 'http://www.google.com' &#125;, computed: &#123; site: &#123; // getter get: function () &#123; return this.name + ' ' + this.url &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.name = names[0] this.url = names[names.length - 1] &#125; &#125; &#125;&#125;)// 调用 setter， vm.name 和 vm.url 也会被对应更新vm.site = '教程 http://www.baidu.com';document.write('name: ' + vm.name);document.write('&lt;br&gt;');document.write('url: ' + vm.url); Vue监听属性监听属性 watch，我们可以通过 watch 来响应数据的变化123456789101112131415&lt;div id = "app"&gt; &lt;p style = "font-size:25px;"&gt;计数器: &#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;button @click = "counter++" style = "font-size:25px;"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1 &#125;&#125;);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');&#125;);&lt;/script&gt; 以下实例进行千米与米之间的换算123456789101112131415161718192021222324252627282930313233&lt;div id = "computed_props"&gt; 千米 : &lt;input type = "text" v-model = "kilometers"&gt; 米 : &lt;input type = "text" v-model = "meters"&gt;&lt;/div&gt;&lt;p id="info"&gt;&lt;/p&gt;&lt;script type = "text/javascript"&gt; var vm = new Vue(&#123; el: '#computed_props', data: &#123; kilometers : 0, meters:0 &#125;, methods: &#123; &#125;, computed :&#123; &#125;, watch : &#123; kilometers:function(val) &#123; this.kilometers = val; this.meters = this.kilometers * 1000 &#125;, meters : function (val) &#123; this.kilometers = val/ 1000; this.meters = val; &#125; &#125; &#125;); // $watch 是一个实例方法 vm.$watch('kilometers', function (newValue, oldValue) &#123; // 这个回调将在 vm.kilometers 改变后调用 document.getElementById ("info").innerHTML = "修改前值为: " + oldValue + "，修改后值为: " + newValue;&#125;)&lt;/script&gt; 通过vue监听事件实现一个简单的购物车12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品价格&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for="iphone in Ip_Json"&gt; &lt;td&gt;&#123;&#123; iphone.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; iphone.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; iphone.price &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button v-bind:disabled="iphone.count === 0" v-on:click="iphone.count-=1"&gt;-&lt;/button&gt; &#123;&#123; iphone.count &#125;&#125; &lt;button v-on:click="iphone.count+=1"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;button v-on:click="iphone.count=0"&gt;移除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 总价：$&#123;&#123;totalPrice()&#125;&#125;&lt;/div&gt; Vue样式绑定class 与 style 是 HTML 元素的属性，用于设置元素的样式，我们可以用 v-bind 来设置样式属性。Vue.js v-bind 在处理 class 和 style 时， 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。 我们可以为 v-bind:class 设置一个对象，从而动态的切换 class:1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 也可以在对象中传入更多属性用来动态切换多个 class 。123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 也可以直接绑定数据里的一个对象,在这里绑定返回对象的计算属性。这是一个常用且强大的模式123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;div v-bind:class="classObject"&gt;&lt;/div&gt;&lt;/div&gt;new Vue(&#123; el: '#app', data: &#123; isActive: true, error: &#123; value: true, type: 'fatal' &#125; &#125;, computed: &#123; classObject: function () &#123; return &#123; base: true, active: this.isActive &amp;&amp; !this.error.value, 'text-danger': this.error.value &amp;&amp; this.error.type === 'fatal', &#125; &#125; &#125;&#125;) 可以把一个数组传给 v-bind:class1&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt; 还可以使用三元表达式来切换列表中的 class12&lt;div v-bind:class="[errorClass ,isActive ? activeClass : '']"&gt;&lt;/div&gt;errorClass 是始终存在的，isActive 为 true 时添加 activeClass 类 style(内联样式)12345678910111213&lt;div id="app"&gt; &lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;教程&lt;/div&gt;&lt;/div&gt;直接绑定到一个样式对象，让模板更清晰&lt;div id="app"&gt; &lt;div v-bind:style="styleObject"&gt;菜鸟教程&lt;/div&gt;&lt;/div&gt;使用数组将多个样式对象应用到一个元素上&lt;div id="app"&gt; &lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;教程&lt;/div&gt;&lt;/div&gt; Vue事件处理器事件监听可以使用 v-on 指令12345678910111213&lt;div id="app"&gt; &lt;button v-on:click="counter += 1"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;&#125;)&lt;/script&gt; 通常情况下，我们需要使用一个方法来调用 JavaScript 方法。v-on 可以接收一个定义的方法来调用。1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click="greet"&gt;Greet&lt;/button&gt;&lt;/div&gt; &lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法app.greet() // -&gt; 'Hello Vue.js!'&lt;/script&gt; 除了直接绑定到一个方法，也可以用内联 JavaScript 语句123456789101112131415&lt;div id="app"&gt; &lt;button v-on:click="say('hi')"&gt;Say hi&lt;/button&gt; &lt;button v-on:click="say('what')"&gt;Say what&lt;/button&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;)&lt;/script&gt; Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。Vue.js通过由点(.)表示的指令后缀来调用修饰符。.stop .prevent .capture .self .once123456789101112131415&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; Vue 允许为 v-on 在监听键盘事件时添加按键修饰符12&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：123456&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt;全部按键别名：.enter .tab .delete .esc .space .up .down .left .right .ctrl .alt .shift .meta Vue表单v-model 指令在表单控件元素上创建双向数据绑定。v-model 会根据控件类型自动选取正确的方法来更新元素。12345678910111213141516171819&lt;div id="app"&gt; &lt;p&gt;input 元素：&lt;/p&gt; &lt;input v-model="message" placeholder="编辑我……"&gt; &lt;p&gt;消息是: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;textarea 元素：&lt;/p&gt; &lt;p style="white-space: pre"&gt;&#123;&#123; message2 &#125;&#125;&lt;/p&gt; &lt;textarea v-model="message2" placeholder="多行文本输入……"&gt;&lt;/textarea&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'Runoob', message2: '教程\r\nhttp://www.baidu.com' &#125;&#125;)&lt;/script&gt; 复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;p&gt;单个复选框：&lt;/p&gt; &lt;input type="checkbox" id="checkbox" v-model="checked"&gt; &lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; &lt;p&gt;多个复选框：&lt;/p&gt; &lt;input type="checkbox" id="runoob" value="Runoob" v-model="checkedNames"&gt; &lt;label for="runoob"&gt;Runoob&lt;/label&gt; &lt;input type="checkbox" id="google" value="Google" v-model="checkedNames"&gt; &lt;label for="google"&gt;Google&lt;/label&gt; &lt;input type="checkbox" id="taobao" value="Taobao" v-model="checkedNames"&gt; &lt;label for="taobao"&gt;taobao&lt;/label&gt; &lt;br&gt; &lt;span&gt;选择的值为: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; checked : false, checkedNames: [] &#125;&#125;)&lt;/script&gt; 单选按钮的双向数据绑定123456789101112131415161718&lt;div id="app"&gt; &lt;input type="radio" id="runoob" value="Runoob" v-model="picked"&gt; &lt;label for="runoob"&gt;Runoob&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="google" value="Google" v-model="picked"&gt; &lt;label for="google"&gt;Google&lt;/label&gt; &lt;br&gt; &lt;span&gt;选中值为: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; picked : 'Runoob' &#125;&#125;)&lt;/script&gt; select下拉列表的双向数据绑定1234567891011121314151617181920&lt;div id="app"&gt; &lt;select v-model="selected" name="fruit"&gt; &lt;option value=""&gt;选择一个网站&lt;/option&gt; &lt;option value="www.baidu.com"&gt;Runoob&lt;/option&gt; &lt;option value="www.google.com"&gt;Google&lt;/option&gt; &lt;/select&gt; &lt;div id="output"&gt; 选择的网站是: &#123;&#123;selected&#125;&#125; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; selected: '' &#125;&#125;)&lt;/script&gt; 在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：12&lt;!-- 在 "change" 而不是 "input" 事件中更新 --&gt;&lt;input v-model.lazy="msg" &gt; 如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：1&lt;input v-model.number="age" type="number"&gt; 这通常很有用，因为在 type=”number” 时 HTML 中输入的值也总是会返回字符串类型。如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：1&lt;input v-model.trim="msg"&gt; Vue组件组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：注册一个全局组件语法格式如下1Vue.component(tagName, options) tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件1&lt;tagName&gt;&lt;/tagName&gt; 所有实例都能用全局组件1234567891011121314&lt;div id="app"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('runoob', &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用123456789101112131415161718&lt;div id="app"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;var Child = &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125; // 创建根实例new Vue(&#123; el: '#app', components: &#123; // &lt;runoob&gt; 将只在父模板可用 'runoob': Child &#125;&#125;)&lt;/script&gt; prop 是父组件用来传递数据的一个自定义属性。父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 “prop”1234567891011121314151617&lt;div id="app"&gt; &lt;child message="hello!"&gt;&lt;/child&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 "this.message" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:message="parentMsg"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 "this.message" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data: &#123; parentMsg: '父组件内容' &#125;&#125;)&lt;/script&gt; 以下实例中将 v-bind 指令将 todo 传到每一个重复的组件中（注意: prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。）12345678910111213141516171819202122&lt;div id="app"&gt; &lt;ol&gt; &lt;todo-item v-for="item in sites" v-bind:todo="item"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; text: 'Runoob' &#125;, &#123; text: 'Google' &#125;, &#123; text: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; 组件可以为 props 指定验证要求。为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如123456789101112131415161718192021222324252627282930313233Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件！我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口(Events interface)，即：使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件以下实例中子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.component('button-counter', &#123; template: '&lt;button v-on:click="incrementHandler"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementHandler: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; 如果你想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如：1&lt;my-component v-on:click.native="doTheThing"&gt;&lt;/my-component&gt; 上面例子中，可以看到 button-counter 组件中的 data 不是一个对象，而是一个函数12345data: function () &#123; return &#123; count: 0 &#125;&#125; 这样的好处就是每个实例可以维护一份被返回对象的独立的拷贝，如果 data 是一个对象则会影响到其他实例,如下例子，123456789101112131415161718192021222324252627&lt;div id="components-demo3" class="demo"&gt; &lt;button-counter2&gt;&lt;/button-counter2&gt; &lt;button-counter2&gt;&lt;/button-counter2&gt; &lt;button-counter2&gt;&lt;/button-counter2&gt;&lt;/div&gt; &lt;script&gt;var buttonCounter2Data = &#123; count: 0&#125;Vue.component('button-counter2', &#123; /* data: function () &#123; // data 选项是一个函数，组件不相互影响 return &#123; count: 0 &#125; &#125;, */ data: function () &#123; // data 选项是一个对象，会影响到其他实例 return buttonCounter2Data &#125;, template: '&lt;button v-on:click="count++"&gt;点击了 &#123;&#123; count &#125;&#125; 次。&lt;/button&gt;'&#125;)new Vue(&#123; el: '#components-demo3' &#125;)&lt;/script&gt; Vue自定义指令除了默认设置的核心指令( v-model 和 v-show ), Vue 也允许注册自定义指令。下面我们注册一个全局指令 v-focus, 该指令的功能是在页面加载时，元素获得焦点12345678910111213141516171819&lt;div id="app"&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt;&lt;/div&gt; &lt;script&gt;// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 也可以在实例使用 directives 选项来注册局部指令，这样指令只能在这个实例中使用123456789101112131415161718192021&lt;div id="app"&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt;&lt;/div&gt; &lt;script&gt;// 创建根实例new Vue(&#123; el: '#app', directives: &#123; // 注册一个局部的自定义指令 v-focus focus: &#123; // 指令的定义 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125; &#125; &#125;&#125;)&lt;/script&gt; 指令定义函数提供了几个钩子函数 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 钩子函数的参数有 el: 指令所绑定的元素，可以用来直接操作 DOM binding: 一个对象，包含以下属性(name: 指令名,value: 指令的绑定值,oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用,expression: 绑定值的表达式或变量名。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”,arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”,modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }) vnode: Vue 编译生成的虚拟节点 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用1234567891011121314151617181920212223&lt;div id="app" v-runoob:hello.a.b="message"&gt;&lt;/div&gt; &lt;script&gt;Vue.directive('runoob', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#app', data: &#123; message: '教程!' &#125;&#125;)&lt;/script&gt; 有时候我们不需要其他钩子函数，我们可以简写函数，如下格式1234Vue.directive('runoob', function (el, binding) &#123; // 设置指令的背景颜色 el.style.backgroundColor = binding.value.color&#125;) 指令函数可接受所有合法的 JavaScript 表达式，以下实例传入了 JavaScript 对象1234567891011121314&lt;div id="app"&gt; &lt;div v-runoob="&#123; color: 'green', text: '菜鸟教程!' &#125;"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.directive('runoob', function (el, binding) &#123; // 简写方式设置文本及背景颜色 el.innerHTML = binding.value.text el.style.backgroundColor = binding.value.color&#125;)new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; Vue路由Vue.js 路由允许我们通过不同的 URL 访问不同的内容。通过 Vue.js 可以实现多视图的单页Web应用Vue.js 路由需要载入 vue-router 库 简单的实现单页应用 是一个组件，该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容。以下实例中我们将 vue-router 加进来，然后配置组件和路由映射，再告诉 vue-router 在哪里渲染它们。代码如下所示：12345678910111213141516&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程，导入 Vue 和 VueRouter，要调用 Vue.use(VueRouter) // 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125; // 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;] // 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;) // 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') // 现在，应用已经启动了！ 了解下更多关于 的属性 to 表示目标路由的链接。 当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象 12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to="home"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href="home"&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to="'home'"&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to="'home'"&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to="&#123; path: 'home' &#125;"&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to="&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;"&gt;Register&lt;/router-link&gt; 设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录 1&lt;router-link :to="&#123; path: '/abc'&#125;" replace&gt;&lt;/router-link&gt; 设置 append 属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b 1&lt;router-link :to="&#123; path: 'relative/path'&#125;" append&gt;&lt;/router-link&gt; 有时候想要 渲染成某种标签，例如&lt; li> 。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航 123&lt;router-link to="/foo" tag="li"&gt;foo&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;li&gt;foo&lt;/li&gt; 设置 链接激活时使用的 CSS 类名。可以通过以下代码来替代。 123456789&lt;style&gt; ._active&#123; background-color : red; &#125;&lt;/style&gt;&lt;p&gt; &lt;router-link v-bind:to = "&#123; path: '/route1'&#125;" active-class = "_active"&gt;Router Link 1&lt;/router-link&gt; &lt;router-link v-bind:to = "&#123; path: '/route2'&#125;" tag = "span"&gt;Router Link 2&lt;/router-link&gt;&lt;/p&gt; 配置当链接被精确匹配的时候应该激活的 class。可以通过以下代码来替代 1234&lt;p&gt; &lt;router-link v-bind:to = "&#123; path: '/route1'&#125;" exact-active-class = "_active"&gt;Router Link 1&lt;/router-link&gt; &lt;router-link v-bind:to = "&#123; path: '/route2'&#125;" tag = "span"&gt;Router Link 2&lt;/router-link&gt;&lt;/p&gt; event声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组 1&lt;router-link v-bind:to = "&#123; path: '/route1'&#125;" event = "mouseover"&gt;Router Link 1&lt;/router-link&gt; Vue过渡动画Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。Vue 提供了内置的过渡封装组件，该组件用于包裹要实现过渡效果的组件123&lt;transition name = "nameoftransition"&gt; &lt;div&gt;&lt;/div&gt;&lt;/transition&gt; 通过以下实例来理解 Vue 的过渡是如何实现的1234567891011121314151617181920&lt;div id = "databinding"&gt;&lt;button v-on:click = "show = !show"&gt;点我&lt;/button&gt;&lt;transition name = "fade"&gt; &lt;p v-show = "show" v-bind:style = "styleobj"&gt;动画实例&lt;/p&gt;&lt;/transition&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;var vm = new Vue(&#123;el: '#databinding', data: &#123; show:true, styleobj :&#123; fontSize:'30px', color:'red' &#125; &#125;, methods : &#123; &#125;&#125;);&lt;/script&gt; 过渡其实就是一个淡入淡出的效果。Vue在元素显示与隐藏的过渡中，提供了 6 个 class 来切换123456v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除 通常我们都使用 CSS 过渡来实现效果1234567891011121314&lt;div id = "databinding"&gt;&lt;button v-on:click = "show = !show"&gt;点我&lt;/button&gt;&lt;transition name="slide-fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt;&lt;/transition&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;new Vue(&#123; el: '#databinding', data: &#123; show: true &#125;&#125;)&lt;/script&gt; CSS 动画用法类似 CSS 过渡，但是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。123456789101112131415&lt;div id = "databinding"&gt;&lt;button v-on:click = "show = !show"&gt;点我&lt;/button&gt;&lt;transition name="bounce"&gt; &lt;p v-if="show"&gt;教程 -- jiaoxue！！！&lt;/p&gt;&lt;/transition&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;new Vue(&#123; el: '#databinding', data: &#123; show: true &#125;&#125;)&lt;/script&gt; 我们可以通过以下特性来自定义过渡类名：123456enter-classenter-active-classenter-to-class (2.1.8+)leave-classleave-active-classleave-to-class (2.1.8+) 自定义过渡的类名优先级高于普通的类名，这样就能很好的与第三方（如：animate.css）的动画库结合使用。123456789101112131415161718&lt;div id = "databinding"&gt;&lt;button v-on:click = "show = !show"&gt;点我&lt;/button&gt;&lt;transition name="custom-classes-transition" enter-active-class="animated tada" leave-active-class="animated bounceOutRight"&gt; &lt;p v-if="show"&gt;菜鸟教程 -- 学的不仅是技术，更是梦想！！！&lt;/p&gt;&lt;/transition&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;new Vue(&#123; el: '#databinding', data: &#123; show: true &#125;&#125;)&lt;/script&gt; 同时使用过渡和动画,Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型 显性的过渡持续时间,在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下你可以用 组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计),也可以定制进入和移出的持续时间123&lt;transition :duration="1000"&gt;...&lt;/transition&gt;&lt;transition :duration="&#123; enter: 500, leave: 800 &#125;"&gt;...&lt;/transition&gt; 可以在属性中声明 JavaScript 钩子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt;methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125;这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。123456789101112131415161718192021222324252627282930313233343536373839&lt;div id = "databinding"&gt;&lt;button v-on:click = "show = !show"&gt;点我&lt;/button&gt;&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:leave="leave" v-bind:css="false" &gt; &lt;p v-if="show"&gt;菜鸟教程 -- 学的不仅是技术，更是梦想！！！&lt;/p&gt;&lt;/transition&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;new Vue(&#123; el: '#databinding', data: &#123; show: false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.transformOrigin = 'left' &#125;, enter: function (el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: '1.4em' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: '1em' &#125;, &#123; complete: done &#125;) &#125;, leave: function (el, done) &#123; Velocity(el, &#123; translateX: '15px', rotateZ: '50deg' &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: '100deg' &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;&#125;)&lt;/script&gt; 可以通过 appear 特性设置节点在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名12345678&lt;transition appear appear-class="custom-appear-class" appear-to-class="custom-appear-to-class" (2.1.8+) appear-active-class="custom-appear-active-class"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子123456789&lt;transition appear v-on:before-appear="customBeforeAppearHook" v-on:appear="customAppearHook" v-on:after-appear="customAfterAppearHook" v-on:appear-cancelled="customAppearCancelledHook"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 可以设置多个元素的过渡，一般列表与描述：需要注意的是当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。123456&lt;transition&gt; &lt;table v-if="items.length &gt; 0"&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;抱歉，没有找到您查找的内容。&lt;/p&gt;&lt;/transition&gt; 12345678&lt;transition&gt; &lt;button v-if="isEditing" key="save"&gt; Save &lt;/button&gt; &lt;button v-else key="edit"&gt; Edit &lt;/button&gt;&lt;/transition&gt; 在一些场景中，也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为12345&lt;transition&gt; &lt;button v-bind:key="isEditing"&gt; &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。例如：1234567891011&lt;transition&gt; &lt;button v-if="docState === 'saved'" key="saved"&gt; Edit &lt;/button&gt; &lt;button v-if="docState === 'edited'" key="edited"&gt; Save &lt;/button&gt; &lt;button v-if="docState === 'editing'" key="editing"&gt; Cancel &lt;/button&gt;&lt;/transition&gt; 也可以重写为12345678910111213141516&lt;transition&gt; &lt;button v-bind:key="docState"&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case 'saved': return 'Edit' case 'edited': return 'Save' case 'editing': return 'Cancel' &#125; &#125;&#125; Vue混入混入 (mixins)定义了一部分可复用的方法或者计算属性。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。12345678910111213141516171819202122var vm = new Vue(&#123; el: '#databinding', data: &#123; &#125;, methods : &#123; &#125;,&#125;);// 定义一个混入对象var myMixin = &#123; created: function () &#123; this.startmixin() &#125;, methods: &#123; startmixin: function () &#123; document.write("欢迎来到混入实例"); &#125; &#125;&#125;;var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component(); 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。以下实例中，Vue 实例与混入对象包含了相同的方法。从输出结果可以看出两个选项合并了。1234567891011var mixin = &#123; created: function () &#123; document.write('混入调用' + '&lt;br&gt;') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; document.write('组件调用' + '&lt;br&gt;') &#125;&#125;); 如果 methods 选项中有相同的函数名，则 Vue 实例优先级会较高。如下实例，Vue 实例与混入对象的 methods 选项都包含了相同的函数123456789101112131415161718192021222324var mixin = &#123; methods: &#123; hellworld: function () &#123; document.write('HelloWorld 方法' + '&lt;br&gt;'); &#125;, samemethod: function () &#123; document.write('Mixin：相同方法名' + '&lt;br&gt;'); &#125; &#125;&#125;;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; start: function () &#123; document.write('start 方法' + '&lt;br&gt;'); &#125;, samemethod: function () &#123; document.write('Main：相同方法名' + '&lt;br&gt;'); &#125; &#125;&#125;);vm.hellworld();vm.start();vm.samemethod(); 可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。1234567891011121314// 为自定义的选项 'myOption' 注入一个处理器。Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;) new Vue(&#123; myOption: 'hello!'&#125;)// =&gt; "hello!" 谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板) Vue.js Ajax(axios)Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。简单的读取 JSON 数据12345678910111213141516new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get('https://www.baidu.com/try/ajax/json_demo.json') .then(response =&gt; (this.info = response)) .catch(function (error) &#123; // 请求失败处理 console.log(error); &#125;); &#125;&#125;) 使用 response.data 读取 JSON 数据1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;h1&gt;网站列表&lt;/h1&gt; &lt;div v-for="site in info" &gt; &#123;&#123; site.name &#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get('https://www.baidu.com/try/ajax/json_demo.json') .then(response =&gt; (this.info = response.data.sites)) .catch(function (error) &#123; // 请求失败处理 console.log(error); &#125;); &#125;&#125;)&lt;/script&gt; GET 方法传递参数格式如下123456789101112131415161718192021// 直接在 URL 上添加参数 ID=12345axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); // 也可以通过 parmas 设置参数：axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); POST 方法12345678910111213141516new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .post('https://www.baidu.com/try/ajax/json_demo.json') .then(response =&gt; (this.info = response)) .catch(function (error) &#123; // 请求失败处理 console.log(error); &#125;); &#125;&#125;) POST 方法传递参数格式如下12345678910axios.post('/user', &#123; firstName: 'Fred', // 参数 firstName lastName: 'Flintstone' // 参数 lastName &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求1234567891011function getUserAccount() &#123; return axios.get('/user/12345');&#125; function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 可以通过向 axios 传递相关配置来创建请求。12345678910111213141516171819202122axios(config)// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;);// GET 请求远程图片axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;);axios(url[, config])// 发送 GET 请求（默认的方法）axios('/user/12345'); 为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求,在使用别名方法时， url、method、data 这些属性都不必在配置中指定1234567axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 处理并发请求的助手函数12axios.all(iterable)axios.spread(callback) 可以使用自定义配置新建一个 axios 实例123456axios.create([config])const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 以下是可用的实例方法。指定的配置将与实例的配置合并1234567axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123; // `url` 是用于请求的服务器 URL url: "/user", // `method` 是创建请求时使用的方法 method: "get", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: "https://some-domain.com/api/", // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 "PUT", "POST" 和 "PATCH" 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;"X-Requested-With": "XMLHttpRequest"&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: "brackets"&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 "PUT", "POST", 和 "PATCH" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: "Fred" &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: "janedoe", password: "s00pers3cret" &#125;, // `responseType` 表示服务器响应的数据类型，可以是 "arraybuffer", "blob", "document", "json", "text", "stream" responseType: "json", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: "XSRF-TOKEN", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: "X-XSRF-TOKEN", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // "proxy" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: "127.0.0.1", port: 9000, auth: : &#123; username: "mikeymike", password: "rapunz3l" &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; axios请求的响应包含以下信息：12345678910111213141516&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: "OK", // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;&#125; 使用 then 时，会接收下面这样的响应,在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。123456789axios.get("/user/12345") .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 可以指定将被用在各个请求的配置默认值,全局的 axios 默认值:123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值：1234567// 创建实例时设置配置的默认值var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 在请求或响应被 then 或 catch 处理前拦截它们。1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器。12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理12345678910111213axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else &#123; // Something happened in setting up the request that triggered an Error console.log('Error', error.message); &#125; console.log(error.config); &#125;); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 状态码在大于或等于500时才会 reject &#125;&#125;) 可以使用 CancelToken.source 工厂方法创建 cancel token取消请求，像这样123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token123456789101112var CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 可以使用同一个 cancel token 取消多个请求 axios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置12345678在浏览器环境，你可以使用 URLSearchParams APIconst params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params);在 node.js里, 可以使用 querystring 模块const querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); Vue响应接口Vue 可以添加数据动态响应接口。例如以下实例，我们通过使用 $watch 属性来实现数据的监听，$watch 必须添加在 Vue 实例之外才能实现正确的响应。实例中通过点击按钮计数器会加 1。setTimeout 设置 10 秒后计算器的值加上 20 。1234567891011121314151617181920&lt;div id = "app"&gt; &lt;p style = "font-size:25px;"&gt;计数器: &#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;button @click = "counter++" style = "font-size:25px;"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1 &#125;&#125;);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');&#125;);setTimeout( function()&#123; vm.counter += 20; &#125;,10000);&lt;/script&gt; Vue 不允许在已经创建的实例上动态添加新的根级响应式属性。Vue 不能检测到对象属性的添加或删除，最好的方式就是在初始化实例前声明根级响应式属性，哪怕只是一个空值。如果我们需要在运行过程中实现属性的添加或删除，则可以使用全局 Vue，Vue.set 和 Vue.delete 方法。 Vue.set 方法用于设置对象的属性，它可以解决 Vue 无法检测添加属性的限制，语法格式如下1234Vue.set( target, key, value )target可以是对象或数组key可以是字符串或数字value可以是任何类型 12345678910111213141516171819&lt;div id = "app"&gt; &lt;p style = "font-size:25px;"&gt;计数器: &#123;&#123; products.id &#125;&#125;&lt;/p&gt; &lt;button @click = "products.id++" style = "font-size:25px;"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;var myproduct = &#123;"id":1, name:"book", "price":"20.00"&#125;; var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1, products: myproduct &#125;&#125;);vm.products.qty = "1";console.log(vm);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');&#125;);&lt;/script&gt; 在以上实例中，使用以下代码在开始时创建了一个变量 myproduct：1var myproduct = &#123;"id":1, name:"book", "price":"20.00"&#125;; 该变量在赋值给了 Vue 实例的 data 对象： var vm = new Vue({ el: ‘#app’, data: { counter: 1, products: myproduct } });如果我们想给 myproduct 数组添加一个或多个属性，我们可以在 Vue 实例创建后使用以下代码：1vm.products.qty = "1"; 在产品中添加了数量属性 qty，但是 get/set 方法只可用于 id，name 和 price 属性，却不能在 qty 属性中使用。我们不能通过添加 Vue 对象来实现响应。 Vue 主要在开始时创建所有属性。 如果我们要实现这个功能，可以通过 Vue.set 来实现12345678910111213141516171819&lt;div id = "app"&gt;&lt;p style = "font-size:25px;"&gt;计数器: &#123;&#123; products.id &#125;&#125;&lt;/p&gt;&lt;button @click = "products.id++" style = "font-size:25px;"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;var myproduct = &#123;"id":1, name:"book", "price":"20.00"&#125;;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1, products: myproduct &#125;&#125;);Vue.set(myproduct, 'qty', 1);console.log(vm);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');&#125;);&lt;/script&gt; Vue.delete 用于删除动态添加的属性,123Vue.delete( target, key )target: 可以是对象或数组key : 可以是字符串或数字 12345678910111213141516171819&lt;div id = "app"&gt; &lt;p style = "font-size:25px;"&gt;计数器: &#123;&#123; products.id &#125;&#125;&lt;/p&gt; &lt;button @click = "products.id++" style = "font-size:25px;"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;var myproduct = &#123;"id":1, name:"book", "price":"20.00"&#125;;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1, products: myproduct &#125;&#125;);Vue.delete(myproduct, 'price');console.log(vm);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');&#125;);&lt;/script&gt; Vue简单的导航菜单12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id="main"&gt; &lt;!-- 激活的菜单样式为 active 类 --&gt; &lt;!-- 为了阻止链接在点击时跳转，我们使用了 "prevent" 修饰符 (preventDefault 的简称)。 --&gt; &lt;nav v-bind:class="active" v-on:click.prevent&gt; &lt;!-- 当菜单上的链接被点击时，我们调用了 makeActive 方法, 该方法在 Vue 实例中创建。 --&gt; &lt;a href="#" class="home" v-on:click="makeActive('home')"&gt;Home&lt;/a&gt; &lt;a href="#" class="projects" v-on:click="makeActive('projects')"&gt;Projects&lt;/a&gt; &lt;a href="#" class="services" v-on:click="makeActive('services')"&gt;Services&lt;/a&gt; &lt;a href="#" class="contact" v-on:click="makeActive('contact')"&gt;Contact&lt;/a&gt; &lt;/nav&gt; &lt;!-- 以下 "active" 变量会根据当前选中的值来自动变换 --&gt; &lt;p&gt;您选择了 &lt;b&gt;&#123;&#123;active&#125;&#125; 菜单&lt;/b&gt;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;// 创建一个新的 Vue 实例var demo = new Vue(&#123; // DOM 元素，挂载视图模型 el: '#main', // 定义属性，并设置初始值 data: &#123; active: 'home' &#125;, // 点击菜单使用的函数 methods: &#123; makeActive: function(item)&#123; // 模型改变，视图会自动更新 this.active = item; &#125; &#125;&#125;);&lt;/script&gt; Vue编辑文本实例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- v-cloak 隐藏未编译的变量，直到 Vue 实例准备就绪。 --&gt;&lt;!-- 元素点击后 hideTooltp() 方法被调用 --&gt; &lt;div id="main" v-cloak v-on:click="hideTooltip"&gt; &lt;!-- 这是一个提示框 v-on:click.stop 是一个点击事件处理器，stop 修饰符用于阻止事件传递 v-if 用来判断 show_tooltip 为 true 时才显示 --&gt; &lt;div class="tooltip" v-on:click.stop v-if="show_tooltip"&gt; &lt;!-- v-model 绑定了文本域的内容 在文本域内容改变时，对应的变量也会实时改变 --&gt; &lt;input type="text" v-model="text_content" /&gt; &lt;/div&gt; &lt;!-- 点击后调用 "toggleTooltip" 方法并阻止事件传递 --&gt; &lt;!-- "text_content" 变量根据文本域内容的变化而变化 --&gt; &lt;p v-on:click.stop="toggleTooltip"&gt;&#123;&#123;text_content&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt;var demo = new Vue(&#123; el: '#main', data: &#123; show_tooltip: false, text_content: '点我，并编辑内容。' &#125;, methods: &#123; hideTooltip: function()&#123; // 在模型改变时，视图也会自动更新 this.show_tooltip = false; &#125;, toggleTooltip: function()&#123; this.show_tooltip = !this.show_tooltip; &#125; &#125;&#125;)&lt;/script&gt; Vue订单列表实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;form id="main" v-cloak&gt; &lt;h1&gt;Services&lt;/h1&gt; &lt;ul&gt; &lt;!-- 循环输出 services 数组, 设置选项点击后的样式 --&gt; &lt;li v-for="service in services" v-on:click="toggleActive(service)" v-bind:class="&#123; 'active': service.active&#125;"&gt; &lt;!-- 显示订单中的服务名，价格 Vue.js 定义了货币过滤器，用于格式化价格 --&gt; &#123;&#123;service.name&#125;&#125; &lt;span&gt;&#123;&#123;service.price | currency&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="total"&gt; &lt;!-- 计算所有服务的价格，并格式化货币 --&gt; Total: &lt;span&gt;&#123;&#123;total() | currency&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/form&gt;&lt;script&gt; // 自定义过滤器 "currency". Vue.filter('currency', function (value) &#123; return '$' + value.toFixed(2);&#125;); var demo = new Vue(&#123; el: '#main', data: &#123; // 定义模型属性 the model properties. The view will loop // 视图将循环输出数组的数据 services: [ &#123; name: 'Web Development', price: 300, active:true &#125;,&#123; name: 'Design', price: 400, active:false &#125;,&#123; name: 'Integration', price: 250, active:false &#125;,&#123; name: 'Training', price: 220, active:false &#125; ] &#125;, methods: &#123; toggleActive: function(s)&#123; s.active = !s.active; &#125;, total: function()&#123; var total = 0; this.services.forEach(function(s)&#123; if (s.active)&#123; total+= s.price; &#125; &#125;); return total; &#125; &#125;&#125;); &lt;/script&gt; Vue搜索页面实例在输入框输入搜索内容，列表显示配置的列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;form id="main" v-cloak&gt; &lt;div class="bar"&gt; &lt;!-- searchString 模型与文本域创建绑定 --&gt; &lt;input type="text" v-model="searchString" placeholder="输入搜索内容" /&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 循环输出数据 --&gt; &lt;li v-for="article in filteredArticles"&gt; &lt;a v-bind:href="article.url"&gt;&lt;img v-bind:src="article.image" /&gt;&lt;/a&gt; &lt;p&gt;&#123;&#123;article.title&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt;&lt;script&gt; var demo = new Vue(&#123; el: '#main', data: &#123; searchString: "", // 数据模型，实际环境你可以根据 Ajax 来获取 articles: [ &#123; "title": "What You Need To Know About CSS Variables", "url": "https://www.runoob.com/css/css-tutorial.html", "image": "https://static.runoob.com/images/icon/css.png" &#125;, &#123; "title": "Freebie: 4 Great Looking Pricing Tables", "url": "https://www.runoob.com/html/html-tutorial.html", "image": "https://static.runoob.com/images/icon/html.png" &#125;, &#123; "title": "20 Interesting JavaScript and CSS Libraries for February 2016", "url": "https://www.runoob.com/css3/css3-tutorial.html", "image": "https://static.runoob.com/images/icon/css3.png" &#125;, &#123; "title": "Quick Tip: The Easiest Way To Make Responsive Headers", "url": "https://www.runoob.com/css3/css3-tutorial.html", "image": "https://static.runoob.com/images/icon/css3.png" &#125;, &#123; "title": "Learn SQL In 20 Minutes", "url": "https://www.runoob.com/sql/sql-tutorial.html", "image": "https://static.runoob.com/images/icon/sql.png" &#125;, &#123; "title": "Creating Your First Desktop App With HTML, JS and Electron", "url": "https://www.runoob.com/js/js-tutorial.html", "image": "https://static.runoob.com/images/icon/html.png" &#125; ] &#125;, computed: &#123; // 计算数学，匹配搜索 filteredArticles: function () &#123; var articles_array = this.articles, searchString = this.searchString; if(!searchString)&#123; return articles_array; &#125; searchString = searchString.trim().toLowerCase(); articles_array = articles_array.filter(function(item)&#123; if(item.title.toLowerCase().indexOf(searchString) !== -1)&#123; return item; &#125; &#125;) // 返回过来后的数组 return articles_array;; &#125; &#125;&#125;);&lt;/script&gt; Vue切换布局实例点击右上角的按钮来切换不同页面布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;form id="main" v-cloak&gt; &lt;div class="bar"&gt; &lt;!-- 两个按钮用于切换不同的列表布局 --&gt; &lt;a class="list-icon" v-bind:class="&#123; 'active': layout == 'list'&#125;" v-on:click="layout = 'list'"&gt;&lt;/a&gt; &lt;a class="grid-icon" v-bind:class="&#123; 'active': layout == 'grid'&#125;" v-on:click="layout = 'grid'"&gt;&lt;/a&gt; &lt;/div&gt; &lt;!-- 我们设置了两套布局页面。使用哪套依赖于 "layout" 绑定 --&gt; &lt;ul v-if="layout == 'grid'" class="grid"&gt; &lt;!-- 使用大图，没有文本 --&gt; &lt;li v-for="a in articles"&gt; &lt;a v-bind:href="a.url" target="_blank"&gt;&lt;img v-bind:src="a.image.large" /&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul v-if="layout == 'list'" class="list"&gt; &lt;!-- 使用小图及标题 --&gt; &lt;li v-for="a in articles"&gt; &lt;a v-bind:href="a.url" target="_blank"&gt;&lt;img v-bind:src="a.image.small" /&gt;&lt;/a&gt; &lt;p&gt;&#123;&#123;a.title&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt;&lt;script&gt; var demo = new Vue(&#123; el: '#main', data: &#123; // 视图模型，可能的值是 "grid" 或 "list"。 layout: 'grid', articles: [&#123; "title": "HTML 教程", "url": "https://www.runoob.com/html/html-tutorial.html", "image": &#123; "large": "https://static.runoob.com/images/mix/htmlbig.png", "small": "https://static.runoob.com/images/icon/html.png" &#125; &#125;, &#123; "title": "CSS 教程", "url": "https://www.runoob.com/css/css-tutorial.html", "image": &#123; "large": "https://static.runoob.com/images/mix/cssbig.png", "small": "https://static.runoob.com/images/icon/css.png" &#125; &#125;, &#123; "title": "JS 教程", "url": "https://www.runoob.com/js/js-tutorial.html", "image": &#123; "large": "https://static.runoob.com/images/mix/jsbig.jpeg", "small": "https://static.runoob.com/images/icon/js.png" &#125; &#125;, &#123; "title": "SQL 教程", "url": "https://www.runoob.com/sql/sql-tutorial.html", "image": &#123; "large": "https://static.runoob.com/images/mix/sqlbig.png", "small": "https://static.runoob.com/images/icon/sql.png" &#125; &#125;, &#123; "title": "Ajax 教程", "url": "https://www.runoob.com/ajax/ajax-tutorial.html", "image": &#123; "large": "https://static.runoob.com/images/mix/ajaxbig.png", "small": "https://static.runoob.com/images/icon/ajax.png" &#125; &#125;, &#123; "title": "Python 教程", "url": "https://www.runoob.com/pyhton/pyhton-tutorial.html", "image": &#123; "large": "https://static.runoob.com/images/mix/pythonbig.png", "small": "https://static.runoob.com/images/icon/python.png" &#125; &#125;] &#125; &#125;); &lt;/script&gt;]]></content>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习scikit-learn实践(1)]]></title>
    <url>%2F2019%2F05%2F20%2Fscikit-learnPractice-1%2F</url>
    <content type="text"><![CDATA[Sklearn的安装&emsp;&emsp;scikit-learn是一个用于机器学习的python开源库，它依赖于NumPy，SciPy和Matplotlib这三个库，所以scikit-learn整个安装顺序就是：先装NumPy，然后装SciPy，接着安装Matplotlib，最后安装scikit-learn。1234python -m pip install --upgrade --target=D:\Python34\Lib\site-packages D:\out\python\numpy-1.16.3-cp36-cp36m-win32.whlpython -m pip install --upgrade --target=D:\Python34\Lib\site-packages D:\out\python\scipy-1.3.0-cp36-cp36m-win32.whlpython -m pip install --upgrade --target=D:\Python34\Lib\site-packages D:\out\python\matplotlib-3.0.3-cp36-cp36m-win32.whlpython -m pip install --upgrade --target=D:\Python34\Lib\site-packages D:\out\python\scikit_learn-0.21.1-cp36-cp36m-win32.whl 安装好模块后测试是否可正常运行123456789#!D:\Python34\python.exe# -*- coding: utf-8 -*-#python3.6.8#测试sklearn是否正常运行from sklearn import datasetsiris = datasets.load_iris()digits = datasets.load_digits()print(digits.data) &emsp;&emsp;scikit-learn内置了很多机器学习模块，也提供了很多数据集。scikit-learn中学习模式的调用，有很强的统一性，很多都是类似的，学会一个，其他基本差不多。 导入模型 建立模型 训练模型 预测Sklearn模块]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>scikit-learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpc+python+wpf]]></title>
    <url>%2F2019%2F05%2F20%2Frpc-python-wpf%2F</url>
    <content type="text"><![CDATA[实验目标:&emsp;&emsp;通过跨语言RPC框架(例如Thrift),Python提供服务,WPF(.NET)负责调用呈现服务。]]></content>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取数据]]></title>
    <url>%2F2019%2F05%2F20%2FcrawlingDataHello%2F</url>
    <content type="text"><![CDATA[安装模块安装requests。1python -m pip install requests 安装beautifulsoup4。1python -m pip install --upgrade --target=D:\Python34\Lib\site-packages D:\out\python\beautifulsoup4-4.7.1-py3-none-any.whl 检查当前pip已安装的模块1pip list Requests：是使用Apache2Licensed许可证的基于Python开发的HTTP库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。BeautifulSoup：是一个模块，该模块用于接收一个HTML或XML字符串，然后将其进行格式化，之后遍可以使用他提供的方法进行快速查找指定元素，从而使得在HTML或XML中查找指定元素变得简单。 12345678910111213141516171819202122232425262728293031323334353637#!D:\Python34\python.exe# -*- coding: utf-8 -*-#python3.6.8import uuidimport requestsfrom bs4 import BeautifulSoupreponse=requests.get('https://www.autohome.com.cn/news/')#reponse.apparent_encoding 获取文本的原来编码#reponse.encoding 对文本编码进行设置#reponse.text 获取文本内容，str类型#reponse.content 获取数据，byte类型#reponse.status_code 获取响应状态码reponse.encoding = reponse.apparent_encoding#获取文本原来编码，使两者编码一致才能正确显示soup=BeautifulSoup(reponse.text,'html.parser')target = soup.find(id="auto-channel-lazyload-article")#find根据属性去获取对象，id,attr,tag...自定义属性自定义标签都可以查找#对于获取的标签对象，obj.text获取文本obj.attrs获取属性字典li_list = target.find_all('li')for li in li_list: a_tag = li.find('a') if a_tag: href = a_tag.attrs.get("href") title = a_tag.find("h3").text img_src = "http:"+a_tag.find("img").attrs.get('src') print(href) print(title) print(img_src) img_reponse = requests.get(url=img_src) #设置一个不重复的图片名 file_name = str(uuid.uuid4())+'.jpg' with open(file_name,'wb') as fp: fp.write(img_reponse.content)]]></content>
      <tags>
        <tag>爬取数据</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV的Python实践(5)]]></title>
    <url>%2F2019%2F05%2F20%2FOpenCvPythonPractice-5%2F</url>
    <content type="text"><![CDATA[Meanshift算法(视频分析) 在视频中找到并跟踪目标对象 Camshift算法(视频分析)在视频中找到并跟踪目标对象 Lucas-Kanade光流BackgroundSubtractorMOG前/背景分割算法静态背景图像估计 BackgroundSubtractorMOG2前/背景分割算法每个像素的贝叶斯分割 BackgroundSubtractorGMG分割算法结合了静态背景图像估计和每个像素的贝叶斯分割 摄像机标定对畸变图像进行修复 姿势估计3D效果 对极几何，对极约束立体图像的深度地图机器学习-K近邻找出测试数据在特征空间中的最近的邻居。 支持向量机SVMK值聚类计算摄影学 图像去噪 图像修补 Haar分类器进行面部检测(眼部检测)]]></content>
      <categories>
        <category>OpenCV的Python实践</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV的Python实践(4)]]></title>
    <url>%2F2019%2F05%2F19%2FOpenCvPythonPractice-4%2F</url>
    <content type="text"><![CDATA[直方图反向投影 &emsp;&emsp;直方图反向投影用来做图像分割，或者在图像中寻找感兴趣的部分。&emsp;&emsp;简单来说，直方图反向投影会输出与输入图像(待搜索)同样大小的图像，其中的每一个像素值代表输入图像上对应点属于目标对象的概率，用更简单的话说，输出图像中像素值越高(越白)的点，越可能代表我们要搜素的目标(在输入图像所在的位置)。&emsp;&emsp;如何实现这个算法呢？ 首先要为一张包含我们待查找目标的图像创建直方图，最好使用颜色直方图，因为一个物体的颜色要比灰度更好的被用来进行图像分割与对象识别。 把这个颜色直方图投影到输入图像中寻找我们的目标。也就是找到输入图像中的每一个像素点的像素值在直方图中对应的概率，得到一个概率图像。 最后设置适当的阈值，对概率图像进行而二值化。就这么简单。 Numpy中的算法： 首先创建两幅颜色直方图，目标图像(待搜索)的直方图(‘M’)，输入图像直方图(‘I’) 计算比值R=M/I,得到反向投影R，根据R这个调色板创建一幅新图像，其中每一个像素代表这个点就是目标的概率。输出图像中灰度值最大的地方就是要查找的目标的位置，如果要找的是一个区域，使用一个阈值对图像进行二值化后可得到结果。 12345678910111213141516171819202122232425262728293031#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')hsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)target=cv2.imread('psbPart.jpg')hsvt=cv2.cvtColor(target,cv2.COLOR_BGR2HSV)M=cv2.calcHist([hsv],[0,1],None,[180,256],[0,180,0,256])I=cv2.calcHist([hsvt],[0,1],None,[180,256],[0,180,0,256])#代码有问题 圆盘算子做卷积 B=D x B 其中D为卷积核''' h,s,v=cv2.split(hsvt)B=R[h.ravel(),s.ravel()]B=np.minimum(B,1)B=B.reshape(hsvt.shape[:2])disc=cv2.getStructuringElement(cv2.MORPH_ELLTPSE,(5,5))B=cv2.filter2D(B,-1,disc)B=np.uint8(B)cv2.normalize(B,B,0,255,cv2.NORM_MINMAX)ret,thresh=cv2.threshold(B,50,255,0)''' OpenCV中的直方图反向投影&emsp;&emsp;OpenCV提供cv2.calcBackProject()做直方图投影。其参数与cv2.calHist基本相同。其中一个参数是我们要查找目标的直方图，同样再使用目标的直方图做反向投影之前，我们应该先对其做归一化处理。返回结果是一个概率图像，再使用圆盘形卷积核对其做卷操作，最后使用阈值进行二值化。 12345678910111213141516171819202122232425262728293031323334353637#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#在输入图像中搜索目标图像import cv2import numpy as npsmallimg_ToFind = cv2.imread('hair.jpg')hsv=cv2.cvtColor(smallimg_ToFind,cv2.COLOR_BGR2HSV)inputImg=cv2.imread('psb.jpg')hsvt=cv2.cvtColor(inputImg,cv2.COLOR_BGR2HSV)hsvhist=cv2.calcHist([hsv],[0,1],None,[180,256],[0,180,0,256])#归一化：原始图像，结果图像，映射到结果图像中的最小最大值，归一化类型#cv2.NORM_MINMAX 对数组所有值进行转化，使它们线性映射到最小值和最大值之间#归一化后的直方图便于显示，成为0到255之间的数。cv2.normalize(hsvhist,hsvhist,0,255,cv2.NORM_MINMAX);dst=cv2.calcBackProject([hsvt],[0,1],hsvhist,[0,180,0,256],1)#此处卷积把分散的点连在一起disc=cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5))dst=cv2.filter2D(dst,-1,disc)ret,thresh=cv2.threshold(dst,50,255,0)thresh=cv2.merge((thresh,thresh,thresh))#裁剪res=cv2.bitwise_and(inputImg,thresh)res=np.hstack((inputImg,thresh,res))while(1): cv2.imshow('res',res) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() 傅里叶变换&emsp;&emsp;傅里叶变换用于分析不同滤波器的频率特性，我们可以使用2D离散傅里叶变换（DFT）分析图像的频域特性。实现DFT的快速算法被称为快速傅里叶变化（FFT）。&emsp;&emsp;对于一个正弦信号，频率为f，如果把它转到频域表示，会在频率f中看到一个峰值，如果信号由采样产生的离散信号组成，会得到类似的频谱图，只不过前面是连续的，现在是离散的。把图像想象成沿两个方向采集的信号。所以对图像同时进行X方向和Y方向的傅里叶变换，就会得到这幅图像的频域表示（频谱图）。 Numpy中的傅里叶变换&emsp;&emsp;np.fft.fft2()可对信号进行频率转换，输出结果是一个复杂的数组。第一个参数是输入图像(要求灰度图)，第二个参数可选，决定输出数组的大小。默认输出数组大小和输入图像的数组大小一样，如果输出结果比输入图像大，输入图像在进行FFT前补0，如果输出结果比输入图像小，输入图像就会被切割。&emsp;&emsp;np.fft.fft2()的结果，频率为0的部分(直流分量)在输出图像的左上角，如果想让它在输出图像的中心，需将结果沿两个方向平移N/2,函数np.fft.fftshift()可以实现这一步。&emsp;&emsp;进行完频率变换后，就可以构建振幅谱了。 1234567891011121314151617181920#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread("psb.jpg",0)f=np.fft.fft2(img)fshift=np.fft.fftshift(f)magnitude_spectrum=20*np.log(np.abs(fshift))plt.subplot(121),plt.imshow(img,cmap='gray')plt.title('Input Image'),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(magnitude_spectrum,cmap='gray')plt.title('Magnitude Spectrum'),plt.xticks([]),plt.yticks([])plt.show() 现在进行频域变换，我们可以在频域对图像进行一些操作。例如高通滤波和重建图像（DFT的逆变换）。比如使用一个60x60的矩形窗口对图像进行掩模操作从而去除低频分量。然后在使用函数np.fft.ifftshift()进行逆平移操作，所以直流分量又回到左上角了，然后使用np.ifft2()进行FFT逆变换，同样得到一堆复杂的数字，对他们取绝对值。123456789101112131415161718192021222324252627282930#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#高通滤波import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread("1.jpg",0)f=np.fft.fft2(img)fshift=np.fft.fftshift(f)magnitude_spectrum=20*np.log(np.abs(fshift))rows,cols=img.shapecrow,ccol=rows/2,cols/2fshift[int(crow-30):int(crow+30),int(ccol-30):int(ccol+30)]=0f_ishift=np.fft.ifftshift(fshift)img_back=np.fft.ifft2(f_ishift)img_back=np.abs(img_back)plt.subplot(131),plt.imshow(img,cmap='gray')plt.title('Input Image'),plt.xticks([]),plt.yticks([])plt.subplot(132),plt.imshow(img_back,cmap='gray')plt.title('Image after HPF'),plt.xticks([]),plt.yticks([])plt.subplot(133),plt.imshow(img_back)plt.title('Result in JET'),plt.xticks([]),plt.yticks([])plt.show() 上面的高通滤波其实是一种边界检测操作。&emsp;&emsp;图像的大部分数据集中在频谱图的低频区域。 OpenCV中的傅里叶变换&emsp;&emsp;OpenCV相应的函数为cv2.dft()和cv2.idft,和前面的输出结果一样，但是是双通道的。第一个通道是结果的实数部分，第二个通道是结果的虚数部分。输入图像首先转换成np.float32格式。 123456789101112131415161718192021#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread("psb.jpg",0)dft=cv2.dft(np.float32(img),flags=cv2.DFT_COMPLEX_OUTPUT)dft_shift=np.fft.fftshift(dft)magnitude_spectrum=20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))plt.subplot(121),plt.imshow(img,cmap='gray')plt.title('Input Image'),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(magnitude_spectrum,cmap='gray')plt.title('magnitude_spectrum'),plt.xticks([]),plt.yticks([])plt.show() 前面我们实现了一个HPF高通滤波，现在我们来做LPF(低通滤波)将高频部分出去除。其实就是对图像进行模糊操作。首先我们需要构建一个掩模，与低频区域对应的地方设置为1，与高频区域对应的地方设置为0.123456789101112131415161718192021222324252627282930313233#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#低通滤波 (图形模糊化)import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread("psb.jpg",0)dft=cv2.dft(np.float32(img),flags=cv2.DFT_COMPLEX_OUTPUT)dft_shift=np.fft.fftshift(dft)magnitude_spectrum=20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))rows,cols=img.shapecrow,ccol=rows/2,cols/2mask=np.zeros((rows,cols,2),np.uint8)mask[int(crow-30):int(crow+30),int(ccol-30):int(ccol+30)]=1fshift=dft_shift*maskf_ishift=np.fft.ifftshift(fshift)img_back=cv2.idft(f_ishift)img_back=cv2.magnitude(img_back[:,:,0],img_back[:,:,1])plt.subplot(121),plt.imshow(img,cmap='gray')plt.title('Input Image'),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(img_back,cmap='gray')plt.title('img_back'),plt.xticks([]),plt.yticks([])plt.show() OpenCV中的函数cv2.dft()cv2.idft()比Numpy快，但Numpy函数使用更加用户友好。 模式匹配模式匹配是用来在一幅大图中搜寻模板图像位置的方法。和2D卷积一样，它也是利用模板图像在输入图像(大图)上滑动，并在每一个位置对模板图像和与其对应的输入图像的子区域进行比较。返回结果是一个灰度图像，每一个像素值代表此区域与模板的匹配程度。OpenCV提供了函数cv2.matchTemplate()123456789101112131415161718192021222324252627282930313233343536#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread("psb.jpg",0)img2=img.copy()template=cv2.imread("psbPart.jpg",0)w,h=template.shape[::-1]methods=['cv2.TM_CCOEFF','cv2.TM_CCOEFF_NORMED','cv2.TM_CCORR','cv2.TM_CCORR_NORMED','cv2.TM_SQDIFF','cv2.TM_SQDIFF_NORMED']for meth in methods: img=img2.copy() method=eval(meth)#eval运算储存在字符串里有效的python表达式 res=cv2.matchTemplate(img,template,method) min_val,max_val,min_loc,max_loc=cv2.minMaxLoc(res) #使用不同的比较方法，对结果的解释不同 if method in[cv2.TM_SQDIFF,cv2.TM_SQDIFF_NORMED]: top_left=min_loc else: top_left=max_loc bottom_right=(top_left[0]+w,top_left[1]+h) cv2.rectangle(img,top_left,bottom_right,255,2) plt.subplot(121),plt.imshow(res,cmap='gray') plt.title('Matching Result'),plt.xticks([]),plt.yticks([]) plt.subplot(122),plt.imshow(img,cmap='gray') plt.title('Detected Point'),plt.xticks([]),plt.yticks([]) plt.suptitle(meth) plt.show() 多对象的模式匹配之前在大图中模版图片只出现了一次，如果模板图片出现了很多次，函数cv2.minMaxLoc()只会给出最大最小值，此时就需要使用阈值了。123456789101112131415161718192021222324#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg_rgb=cv2.imread("psbmul.jpg")img_gray=cv2.cvtColor(img_rgb,cv2.COLOR_BGR2GRAY)template=cv2.imread('psbPart.jpg',0)w,h=template.shape[:2]res=cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED)threshold=0.8loc=np.where(res&gt;=threshold)for pt in zip(*loc[::-1]): cv2.rectangle(img_rgb,pt,(pt[0]+w,pt[1]+h),(0,0,255),2) while(1): cv2.imshow('res',img_rgb) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() Hough霍夫直线变换&emsp;&emsp;霍夫变换在检测各种形状的技术中非常流行，如果待检测的形状可以用数学表达式写出来，就可以使用霍夫变换检测它，即使要检测的形状存在一点破坏或者扭曲也可以使用。&emsp;&emsp;下面以使用霍夫变换检测直线为例子说明&emsp;&emsp;一条直线的数学表达式y=mx+c或者r=xcosO+YsinO表示，r表示原点到直线的垂直距离，O是直线的垂线与横轴顺时针方向的夹角。cv2.HoughLines()返回值就是(r,O),r的单位是像素，O的单位是弧度。 第一个参数：二值化图像(所以霍夫变换之前需要二值化或Canny边缘检测) 第二，第三个参数：分别代表r和O的精确度。 第四个参数：阈值，只有累加其中的值高于阈值时才被认为是一条直线。也可看成是能检测到的直线的最短长度(以像素点为单位)12345678910111213141516171819202122232425#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread("psb.jpg")gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)edges=cv2.Canny(gray,50,150,apertureSize=3)minLineLength=100maxLineGap=10lines=cv2.HoughLinesP(edges,1,np.pi/180,100,minLineLength,maxLineGap)for x1,y1,x2,y2 in lines[0]: cv2.line(img,(x1,y1),(x2,y2),(0,0,255),2) while(1): cv2.imshow('edges',edges) cv2.imshow('res',img) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() Hough霍夫圆环变换12345678910111213141516171819202122#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread("psb.jpg",0)img=cv2.medianBlur(img,5)cimg=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)circles=cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,1,20,param1=50,param2=30,minRadius=0,maxRadius=0)circles=np.uint16(np.around(circles))for i in circles[0,:]: cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),2) cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)while(1): cv2.imshow('detected circles',cimg) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() 分水岭算法图像分割1234567891011121314151617181920212223242526272829303132333435#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread("code.jpg")gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret,thresh=cv2.threshold(gray,0,255,cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)#noise removalkernel=np.ones((3,3),np.uint8)opening=cv2.morphologyEx(thresh,cv2.MORPH_OPEN,kernel,iterations=2)#sure background areasure_bg=cv2.dilate(opening,kernel,iterations=3)dist_transform=cv2.distanceTransform(opening,1,5)ret,sure_fg=cv2.threshold(dist_transform,0.7*dist_transform.max(),255,0)sure_fg=np.uint8(sure_fg)unknown=cv2.subtract(sure_bg,sure_fg)ret,markers1=cv2.connectedComponents(sure_fg)markers=markers1+1markers[unknown==255]=0markers3=cv2.watershed(img,markers)img[markers3==-1]=[255,0,0]while(1): cv2.imshow('res',img) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() 用GrabCut算法进行交互式前景提取图像特征的提取与描述Harris角点检测特征检测器。 Shi-Tomasi角点检测(适合跟踪的图像特征)特征检测器。 尺度不变特征变换(SIFT)使用SIFT算法进行关键点检测和描述。 加速稳健特征算法(SURF)加速版的SIFT算法。 FAST算法特征检测器BRIEF特征点描述符一种对特征点描述符计算和匹配的快速方法 ORB算法FAST关键点检测和BRIEF关键点描述符的结合体。 Brute-Force特征匹配FLANN匹配器使用特征匹配和单应性查找对象]]></content>
      <categories>
        <category>OpenCV的Python实践</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV的Python实践(3)]]></title>
    <url>%2F2019%2F05%2F18%2FOpenCvPythonPractice-3%2F</url>
    <content type="text"><![CDATA[图像梯度 &emsp;&emsp;图像梯度原理：简单来说就是求导。&emsp;&emsp;OpenCV提供了三种不同的梯度滤波器，或者说高通滤波器：Sobel，Scharr和Laplacian。Sobel和Scharr是求一阶或二阶导数。Scharr是对Sobel（使用小的卷积核求解梯度角度时）的优化，Laplacian是求二阶导数。 Sobel算子和Scharr算子&emsp;&emsp;Sobel算子是高斯平滑与微分操作的结合体，它的抗噪音能力很好。可以设定求导的方向（xorder或yorder）。还可以设定使用的卷积核的大小（ksize），如果ksize=-1，会使用3x3的Scharr滤波器，效果会更好，若速度相同，在使用3x3滤波器时尽量使用Scharr。&emsp;&emsp;3x3的Scharr滤波器卷积核如下： X方向 -3 0 3 -10 0 10 -3 0 3 + Y方向 -3 -10 -3 0 0 0 3 10 3 2.Laplacian算子(拉普拉斯算子)&emsp;&emsp;拉普拉斯算子可以使用二阶导数的形式定义，可假设其离散实现类似于二阶Sobel导数，事实上OpenCV在计算拉普拉斯算子时直接调用Sobel算子。&emsp;&emsp;拉普拉斯滤波器使用的卷积核：123456789101112131415161718192021222324#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#用以上三种滤波器对同一幅图像进行操作，卷积核使用为5x5。import cv2import numpyfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg',0)laplacian = cv2.Laplacian(img,cv2.CV_64F)sobelx = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)sobely = cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)plt.subplot(2,2,1),plt.imshow(img,cmap='gray')plt.title('original'),plt.xticks([]),plt.yticks([])plt.subplot(2,2,2),plt.imshow(laplacian,cmap='gray')plt.title('laplacian'),plt.xticks([]),plt.yticks([])plt.subplot(2,2,3),plt.imshow(sobelx,cmap='gray')plt.title('Sobel X'),plt.xticks([]),plt.yticks([])plt.subplot(2,2,4),plt.imshow(sobely,cmap='gray')plt.title('Sobel Y'),plt.xticks([]),plt.yticks([])plt.show() 当我们可以通过参数-1来设定输出图像的深度（数据类型）与原图像保持一致，但是我们在代码中使用的却是cv2.CV_64F。这是为什么？想象一下一个从黑到白的边界的导数是正数，而一个从白到黑的边界的导数却是负数。如果原图像的深度是np.int8时，所有的负值都会被截断变成0。换句话就是把边界丢失掉。所以如果这两种边界你都想检测到，最好的办法就是将输出的数据类型设置的更高，比如cv2.CV_16S等，取绝对值然后再把它转回到cv2.CV_8U。 Canny边缘检测原理 噪音去除&emsp;&emsp;由于边缘检测很容易受到噪音影响，所以第一步是使用5x5的高斯滤波器去除噪音。 计算图像梯度&emsp;&emsp;对平滑后的图像使用Sobel算子计算水平方向和竖直方向的一阶导数（图像梯度）（Gx和Gy）。根据得到的这两幅梯度图找到边界的梯度和方向。公式如下：&emsp;&emsp;梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两条对角线。 非极大值抑制&emsp;&emsp;在获得梯度的方向和大小之后，应该对整幅图想做一个扫描，出去那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。&emsp;&emsp;现在你得到的是一个包含“窄边界”的二值图像。 滞后阀值&emsp;&emsp;现在要确定那些边界才是真正的边界，需要设置两个阀值：minVal和maxVal。当图像的灰度梯度高于maxVal时被认为是真的边界，那些低于minVal的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正边界点相连，如果是，就认为它也是边界点，如果不是就抛弃。OpenCV中的Canny边界检测&emsp;&emsp;cv2.Canny()第一个参数是输入图像，第二和第三个分别是minVal和maxVal。第三个参数设置用来计算图像梯度的Sobel卷积核的大小，默认值为3。最后一个参数是L2gradient，它可以用来设定求梯度大小的方程。如果设为True，就使用我们上面提到过的方程，否则使用方程代替，默认为False12345678910111213141516#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg',0)edges = cv2.Canny(img,100,200)plt.subplot(121),plt.imshow(img,cmap='gray')plt.title('original'),plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(edges,cmap='gray')plt.title('edge'),plt.xticks([]),plt.yticks([])plt.show() 图像金字塔原理&emsp;&emsp;一般情况下，我们要处理是一副具有固定分辨率的图像。但是特别情况下我们需要对同一个图像的不同分辨率的子图像进行处理，如查找图像中的某个目标，如人脸，我们不知道目标在图像中的尺寸大小。这种情况下，我们需要创建一组图像，这些图像是具有不同分辨率的原始图像。我们把这组图像叫做图像金字塔。就是同一图像的不同分辨率的子图集合。我们把最大的图像放在底部，最小的放在顶部，看起来就像一座金字塔。有两类：高斯金字塔和拉普拉斯金字塔。 高斯金字塔&emsp;&emsp;高斯金字塔的顶部是通过将底部图像中的连续的行和列去除得到的。顶部图像中的每个像素值等于下一层图像中5个像素的高斯加权平均值。这样操作一次一个MxN的图像就变成了一个M/2xN/2的图像。所以这幅图像的面积就变为原来图像面积的四分之一。这被称为Octave。连续这样的操作，我们就会得到一个分辨率不断下降的图像金字塔。可以使用函数cv2.pyrDown()和cv2.pyrUp()构建图像金字塔。&emsp;&emsp;cv2.pyrDown从一个高分辨率大尺寸的图像向上构建一个金字塔（尺寸变小，分辨率降低）1234567891011121314151617#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import numpy as npimport cv2img = cv2.imread('psb.jpg')lower_reso = cv2.pyrDown(img)while(1): cv2.imshow('img',img) cv2.imshow('lower_reso',lower_reso) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() &emsp;&emsp;cv2.pyrUp从一个低分辨率小尺寸的图像向上构建一个金字塔（尺寸变大，但分辨率不会增加）12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import numpy as npimport cv2img = cv2.imread('psb.jpg')lower_reso = cv2.pyrDown(img)higher_reso2 = cv2.pyrUp(img)while(1): cv2.imshow('img',img) cv2.imshow('lower_reso',lower_reso) cv2.imshow('higher_reso2',higher_reso2) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() higher_reso2和higher_reso是不同的。因为一旦使用cv2.pyrDown图像的分辨率就会降低，信息就会被丢失。 拉普拉斯金字塔拉普拉斯金字塔可以由高斯金字塔计算得来。公式如下：拉普拉斯金字塔的图像看起来就像是边界图，其中很多像素都是0，常被用在图像压缩中。 使用金字塔进行图像融合&emsp;&emsp;在图像缝合中，由于连接区域图像像素的不连续，整幅图看起来会很差，金字塔就可以实现无缝连接。实现步骤： 读入两幅图 构建各自的高斯金字塔(6层) 根据高斯金字塔计算拉普拉斯金字塔 在拉普拉斯的每一层进行图像融合 根据融合后的图像金字塔重建原始图像&emsp;&emsp;重建原始图像过程：什么是轮廓&emsp;&emsp;轮廓可以简单认为成连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。 为了准确，要使用二值化图像。需要进行阀值化处理或者Canny边界检测。 查找轮廓的函数会修改原始图像。如果之后想继续使用原始图像，应该将原始图像储存到其他变量中。 OpenCV中，查找轮廓就像在黑色背景中超白色物体。你应该记住，要找的物体应该是白色而背景应该是黑色。 在二值图像中查找轮廓使用函数cv2.findContours(),有三个参数，第一个是输入图像，第二个是轮廓检索模式，第三个是轮廓近似方法。返回值有三个，第一个是图像，第二个是轮廓，第三个是（轮廓的）层析结构。轮廓（第二个返回值）是一个Python列表，其中储存这图像中所有轮廓。每一个轮廓都是一个Numpy数组，包含对象边界点（x，y）的坐标。绘制轮廓&emsp;&emsp;函数cv2.drawContours()可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。它的第一个参数是原始图像，第二个参数是轮廓，一个python列表，第三个参数是轮廓的索引（在绘制独立轮廓是很有用，当设置为-1时绘制所有轮廓）。接下来的参数是轮廓的颜色和厚度。123456789101112131415161718192021222324#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import numpy as npimport cv2img = cv2.imread('psb.jpg')imgray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret,thresh = cv2.threshold(imgray,127,255,0)contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)#绘制独立轮廓，如第四个轮廓imag = cv2.drawContours(img,contours,-1,(0,255,0),3)#但是大多数时候，下面方法更有用#imag = cv2.drawContours(img,contours,3,(0,255,0),3)while(1): cv2.imshow('img',img) cv2.imshow('imgray',imgray) cv2.imshow('imag',imag) if cv2.waitKey(1) == ord('q'): breakcv2.destroyAllWindows() 轮廓的近似方法&emsp;&emsp;之前提到轮廓是一个形状具有相同灰度值的边界，它会存储形状边界上所有的（x,y）坐标。实际上我们不需要所有的点，当需要直线时，找到两个端点即可。cv2.CHAIN_APPROX_SIMPLE可以实现。它会将轮廓上的冗余点去掉，压缩轮廓，从而节省内存开支。&emsp;&emsp;下面用矩阵来演示，在轮廓列表中的每一个坐标上画一个蓝色圆圈。第一个显示使用cv2.CHAIN_APPROX_NONE的效果，一共734个点，第二个图是使用cv2.CHAIN_APPROX_SIMPLE的结果，只有4个点。 轮廓特征 矩&emsp;&emsp;图像的矩可以帮助我们计算图像的质心，面积等。&emsp;&emsp;函数cv2.moments()会将计算得到的矩以一个字典的形式返回。 1234567891011121314151617#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import numpy as npimport cv2img = cv2.imread('psb.jpg',0)ret,thresh = cv2.threshold(img,127,255,0)contours,hierarchy=cv2.findContours(thresh,1,2)cnt=contours[0]M=cv2.moments(cnt)print(M)#根据这些矩的值，我们可以计算出对象的重心cx=int(M['m10']/M['m00'])cy=int(M['m01']/M['m00']) 轮廓面积&emsp;&emsp;可以使用函数cv2.contourArea()计算得到，也可以用矩（0阶矩），M[‘m00’]。 1area=cv2.contourArea(cnt) 轮廓周长&emsp;&emsp;也被称为弧长。可以使用函数cv2.arcLength()计算得到。这个函数的第二参数可以用来指定对象的形状是闭合的（True），还是打开的（一条曲线）。 1perimeter = cv2.arcLength(cnt,True) 轮廓近似&emsp;&emsp;将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定，使用的Douglas-Peucker算法，可以自己Google。假设我们要在一幅图像中查找一个矩形，但是由于图像的种种原因我们不能得到一个完美的矩形，而是一个“坏形状”，现在就可以使用这个函数来近似这个形状，第二个参数是epsilon，它是从原始轮廓到近似轮廓的最大距离，它是一个准确度参数。 12epsilon=0.1*cv2.arcLength(cnt,True)approx = cv2.approxPolyDP(cnt,epsilon,True) 凸包&emsp;&emsp;凸包与轮廓近似相似，但不同，虽然有些情况下它们给出的结果是一样的。函数cv2.convexHull()可以用来检测一个曲线是否具有凸性缺陷，并能纠正缺陷。一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去了就被叫做凸性缺陷。例如下图中的手，红色曲线显示了手的凸包，凸性缺陷被双箭头标出来了。 1234567hull = cv2.convexHull(points,hull,clockwise,returnPoints)#points 我们要传入的轮廓#hull 输出，通常不需要#clockwise 方向标志，如果设置为True，输出的凸包是顺时针方向的，否则为逆时针方向。#returnPoints默认值为True。它会返回凸包上点的坐标，如果设置为False，就会返回与凸包点对应的轮廓上的点。要获得上图的凸包，可以用下面命令：hull=cv2.convexHull(cnt) 但是如果你想获得凸性缺陷，需要把returnPoints设置为False。以上面矩形为例，首先我们找到他的轮廓从cnt。现在把returnPoints设置为True查找凸包，得到的就是矩形的四个角点。把returnPoints设置为False，得到的是轮廓点的索引。 凸性检测&emsp;&emsp;函数cv2.isContourConvex()可以检测一个曲线是不是凸的。它只能返回True或者False。 1k=cv2.isContourConvex(cnt) 边界矩形&emsp;&emsp;直边界矩形，一个直矩形，没有旋转。不会考虑对象是否旋转。所以边界矩形的面积不是最小的。可以使用函数cv2.boundingRect()查找得到 123#（x,y）为矩形左上角的坐标，（w,h）是矩形的宽和高x,y,w,h=cv2.boundingRect(cnt)img=cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2) 旋转的边界矩形，这个边界矩形是面积最小的，因为它考虑了对象的旋转。用函数cv2.minAreaRect()。返回的是一个Box2D结构，其中包含矩形最上角角点坐标（x，y）矩形的宽和高（w,h）以及旋转角度。但是要绘制这个矩形需要矩形的4个角点，可以通过函数cv2.boxPoints()获得。其中绿色的为直矩形，红色为旋转矩形。 最小外接圆&emsp;&emsp;函数cv2.minEnclosingCircle()可以帮我们找到一个对象的外接圆。它是所有能够包括对象的圆中面积最小的一个。1234(x,y),radius = cv2.minEnclosingCircle(cnt)center = (int(x),int(y))radius = int(radius)img = cv2.circle(img,center,radius,(0,255,0),2) 椭圆拟合&emsp;&emsp;使用函数cv2.ellipse()，返回值其实就是旋转边界矩形的内切圆。12ellipse = cv2.fitEllipse(cnt)img = cv2.ellipse(img,ellipse,(0,255,0),2) 直线拟合&emsp;&emsp;可以根据一组点拟合出一条直线，同样我们也可以为图像中的白色点拟合出一条直线。12345rows,cols = img.shape[:2][vx,vy,x,y]=cv2.fitLine(cnt,cv2.DIST_L2,0,0.01,0.01)lefty=int((x*vy/vx)+y)righty=int(((cols-x)*vy/vx)+y)img = cv2.line(img,(cols-1,righty),(0,lefty),(0,255,0),2) 轮廓的性质 长宽比边界矩形的宽高比 12x,y,w,h=cv2.boundingRect(cnt)aspect_ratio = float(w)/h Extent轮廓面积与边界矩形面积的比 1234area=cv2.contourArea(cnt)x,y,w,h=cv2.boundingRect(cnt)rect_area=w*hextent=float(area)/rect_area Solidity轮廓面积与凸包面积的比 1234area=cv2.contourArea(cnt)hull=cv2.convexHull(cnt)hull_area=cv2.contourArea(hull)solidity=float(area)/hull_area 与轮廓面积相等的圆形的直径 12area=cv2.contourArea(cnt)equi_diameter=np.sqrt(4*area/np.pi) 方向对象的方向，下面的方法还会返回长轴和短轴的长度 1(x,y),(MA,ma),angle=cv2.fitEllipse(cnt) 掩模和像素点有时我们需要构成对象的所有像素点 1234mask=np.zeros(imgray.shate,np.uint8)#这里一定要使用参数-1，绘制填充的轮廓cv2.drawContours(mask,[cnt],0,255,-1)pixelpoints=np.transpose(np.nonzero(mask)) 最大值和最小值及它们的位置可以使用掩模图像得到这些参数 1min_val,max_val,min_loc,max_loc=cv2.minMaxLoc(imgray,mask=mask) 平均颜色及平均灰度同样使用相同的掩模来求得 1mean_val=cv2.mean(im,mask=mask) 9.极点一个对象最上，最下，最左，和最右的点1234leftmost=tuple(cnt[cnt[:,:,0].argmin()[0])rightmost=tuple(cnt[cnt[:,:,0].argmax()[0])topmost=tuple(cnt[cnt[:,:,1].argmin()[0])bottommost=tuple(cnt[cnt[:,:,1].argmax()[0]) 轮廓：更多函数 凸缺陷找到凸缺陷12hull=cv2.convexHull(cnt,returnPoints=False)defects=cv2.convexityDefects(cnt,hull) 它会返回一个数组，其中每一行包含的值是[起点，终点，最远的点，到最远点的近似距离] Point Polygon Test求解图像中的一个点到一个对象轮廓的最短距离。如果点再轮廓的外部，返回值为负，如果在轮廓上，返回值为0，如果在轮廓内部，返回值为正。1dist = cv2.pointPolygonTest(cnt,(50,50),True) 此函数的第三个参数是measureDist。如果设置为True，就会计算最短距离。如果是False，只会判断这个点与轮廓之间的位置关系（返回值为+1,-1,0） 形状匹配函数cv2.matchShape()可以帮我们比较两个形状或者轮廓的相似度，如果返回值越小，匹配越好，它是根据Hu矩来计算的。 轮廓的层次结构 什么是层次结构&emsp;&emsp;通常我们使用函数cv2.findContours 在图片中查找一个对象。有时对象可能位于不同的位置。还有些情况，一个形状在另外一个形状的内部，这种情况下我们称外部的形状为父，内部的形状为子。按照这种方式分类，一幅图像中的所有轮廓之间就建立父子关系。这样我们就可以确定一个轮廓与其他轮廓是怎样连接的，比如它是不是某个轮廓的子轮廓，或者是父轮廓。这种关系就成为组织结构。 opencv中层次结构OpenCV使用一个含有四个元素的数组表示父子关系，【Next，Previous，First_Child，Parent】Next表示同一级组织结构中的下一个轮廓。Previous 示同一级结构中的前一个轮廓。First_Child 示它的第一个子轮廓。Parent 示它的父轮廓。 轮廓检索模式RETR_LIST 从的度来看中应是简单的。它只是提取所有的轮廓而不去创建任何父子关系。换句就是‘’人人平等‘’它们属于同一级组织轮廓。所以在种情况下组织结构数组的第三和第四个数是 -1。但是很明 显Next 和 Previous 有对应的值。RETR_EXTERNAL 如果你择种模式的只会回外的的轮廓，所有的子轮廓会忽略掉。 直方图 直方图原理&emsp;&emsp;直方图是一个简单的表，它给出了一幅图像或一组图像中拥有给定数值的像素数量。例如灰度图像的直方图有265个条目(或称为容器)。0号容器给出值为0的像素个数，1号容器给出值为1的像素个数，依次类推。显然对直方图的所有项求和会得到像素的总数。直方图也可以被归一化，归一化后的所有项之和等于1，在这种情况下，每一项给出的都是拥有特定数值的像素在图像中占的比例。&emsp;&emsp;通过直方图可以对整幅图像的灰度分布有一个整体的了解。直方图的X轴是灰度值（0,255），Y轴是图片中具有同一个灰度值的点的数目。&emsp;&emsp;通过直方图我们可以对图像的对比度，亮度，灰度分布等有一个直观的认识。相关术语： BINS:每个灰度值对应的像素数。如果像素值为0到255，就需要256个数来显示上面的直方图。 DIMS:收集数据的参数数目。 RANGE:要统计的灰度值范围，一般[0,256]. 函数cv2.calcHist可以统计一幅图像的直方图。cv2.calcHist(images,channels,mask,histSize,range[,hist[,accumulate]]) images:原图像(格式uint8或float32),传入函数时应用中括号括起来，如[img] channels:传入函数时应用中括号括起来 mask:掩模图像 histSize:BIN的数目，应用中括号括起来，如[256] ranges:像素范围，通常[0,256] 以灰度格式加载一幅图像，并统计图像的直方图。1234567891011121314151617#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg')hist=cv2.calcHist([img],[0],None,[256],[0,256])#参数中只有mask是没有中括号的while(1): cv2.imshow('hist',hist) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() hist是一个256x1的数组，每一个值代表与次灰度值对应的像素点数目。 使用Numpy统计直方图&emsp;&emsp;Numpy中的np.histogram()可以统计直方图。12345678910111213141516#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg')hist,bins=np.histogram(img.ravel(),256,[0,256])while(1): cv2.imshow('bins',bins) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() matplotlib读取图片显示颜色失真的问题原因是matplotlib的多通道顺序是bgr，跟openCV中的rbg顺序不同。1234567891011121314151617181920212223#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')#重新安排多通道顺序b,g,r = cv2.split(img)img2 = cv2.merge([r, g, b])plt.subplot(121)plt.imshow(img, cmap = 'gray', interpolation = 'bicubic')plt.xticks([])plt.yticks([])plt.subplot(122)plt.imshow(img2, cmap = 'gray', interpolation = 'bicubic')plt.xticks([])plt.yticks([])plt.show() 绘制直方图 使用Matplotlib绘图函数。（简单方法）123456789101112131415161718#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg',0)#plt.hist(img,ravel(),hitsizes,ranges,color=)#img.ravel()将原图像的array数组转成一维的数组#hitsizes 为直方图的灰度级数#ranges为灰度范围[0,255]#color是参数，需要使用color='r'来指定颜色plt.hist(img.ravel(),256,[0,256])plt.show() &emsp;&emsp;分别绘制查看各通道的直方图12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')color=('b','g','r')#对列表或数组既要遍历索引又要遍历元素时#使用内置enumerate更加直接优美#enumerate会将数组或列表组成一个索引序列for i,col in enumerate(color): histr=cv2.calcHist([img],[i],None,[256],[0,256]) plt.plot(histr,color=col) plt.xlim([0,256])plt.show() 使用掩模&emsp;&emsp;要统计图像局部区域的直方图，需要构建一幅掩模图像。&emsp;&emsp;将要统计的部分设置成白色，其余为黑色，就构成了掩模图像。12345678910111213141516171819202122232425#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')#创建掩模图像mask=np.zeros(img.shape[:2],np.uint8)mask[100:200,100:300]=255masked_img=cv2.bitwise_and(img,img,mask=mask)hist_full=cv2.calcHist([img],[0],None,[256],[0,256])hist_mask=cv2.calcHist([img],[0],mask,[256],[0,256])plt.subplot(221),plt.imshow(img,'gray')plt.subplot(222),plt.imshow(mask,'gray')plt.subplot(223),plt.imshow(masked_img,'gray')plt.subplot(224),plt.plot(hist_full),plt.plot(hist_mask)plt.xlim([0,256])plt.show() OpenCV以灰度模式加载彩图1img = cv2.imread('psb.jpg',0) 直方图均衡化&emsp;&emsp;如果图片整体很亮，那所有像素应该都会很高，但是一幅高质量的图像的像素值分布应该很广泛。所以偏亮的直方图(像素偏高)你应该把它的直方图做一个横向拉伸。这就是直方图均衡化，通常能改善图像的对比度。&emsp;&emsp;偏亮的图的直方图大部分在灰度值较高的地方，我们希望直方图分布比较分散，能够涵盖整个x轴，所以需要一个变换函数能把现在的直方图映射到一个广泛分布的直方图中，这就是直方图均衡化需要做的事。&emsp;&emsp;即使是偏暗的图片，经过均衡化之后也能得到相同的结果，直方图均衡化是使所有图片具备相同的亮度条件的参考工具，在很多情况，如脸部识别，训练分类器前，训练集的所有图片都要先进行直方图均衡化达到相同的亮度条件。 OpenCV中的灰度图直方图均衡化cv2.equalizeHist(img)，将要均衡化的原图像(要求是灰度图像)作为参数传入，则返回值即为均衡化后的图像。 1234567891011121314151617181920#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg',0)equ=cv2.equalizeHist(img)#numpy拼接数组#np.vstack():在竖直方向上堆叠#np.hstack():在水平方向上平铺res=np.hstack((img,equ))while(1): cv2.imshow('res',res) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() OpenCV中的彩色图片直方图均衡化 1234567891011121314151617181920212223242526272829303132#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltdef hisEqulColor(img): ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB) channels = cv2.split(ycrcb) print(str(len(channels))) cv2.equalizeHist(channels[0], channels[0]) cv2.merge(channels, ycrcb) cv2.cvtColor(ycrcb, cv2.COLOR_YCR_CB2BGR, img) return imgimg0 = cv2.imread('psb.jpg')#数组的复制img=img0.copy()eq=hisEqulColor(img)#numpy拼接数组#np.vstack():在竖直方向上堆叠#np.hstack():在水平方向上平铺res=np.hstack((img0,eq))while(1): cv2.imshow('res',res) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() 有限对比适应性直方图均衡化&emsp;&emsp;之前的直方图均衡化会改变整个图像的对比度，很多情况这样效果并不好(直方图均衡化改变对比度的原因是因为该图的直方图并不集中在某个区域)。&emsp;&emsp;自适应的直方图均衡化，整幅图被分成很多个小块，称为tiles（OpenCV中tile大小默认8x8）,然后对每一个小块分别直方图均衡化。所以在每一个区域中，各自的直方图会集中在某一个小的区域内(除非噪声干扰)，如果有噪声的话，噪声会被放大，为避免这种情况，要使用对比度限制，对每个小块来说，如果直方图中的bins超过对比度上限的话，就把其中的像素点均匀分散到其他bins中，然后进行直方图均衡化。最后，为去除每一个小块之间人造的边界，再使用双线性差值，对小块进行缝合。 123456789101112131415161718#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#灰度图的自适应直方图均衡化import cv2import numpy as npfrom matplotlib import pyplot as pltimg0 = cv2.imread('psb.jpg',0)clahe=cv2.createCLAHE(clipLimit=2.0,tileGridSize=(8,8))cli=clahe.apply(img0)while(1): cv2.imshow('res',cli) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() 2D直方图&emsp;&emsp; 前面绘制了一维直方图，之所以称为一维，因为只考虑了图像的一个特征：灰度。但在2d直方图中我们要考虑两个图像特征，彩图直方图通常情况下我们需要考虑每个的颜色(Hue)和饱和度(Saturation)。根据这两个特征绘制2D直方图。 OpenCV中的2D直方图绘制彩色直方图，首先需要将图像的颜色空间从BGR转换到HSV.参数做如下修改 channels=[0,1] 因为需要同时处理H和S两个通道 bins=[180,256] H通道为180，S通道为256 range=[0,180,0,256] H取值范围0-180，S取值范围0-256 123456789101112131415161718#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')hsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)hist=cv2.calcHist([hsv],[0,1],None,[180,256],[0,180,0,256])while(1): cv2.imshow('hist',hist) if cv2.waitKey() == ord('q'): breakcv2.destroyAllWindows() 12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')b,g,r = cv2.split(img)img2 = cv2.merge([r, g, b])hsv=cv2.cvtColor(img2,cv2.COLOR_BGR2HSV)hist=cv2.calcHist([hsv],[0,1],None,[180,256],[0,180,0,256])plt.imshow(hist,interpolation='nearest')plt.show()]]></content>
      <categories>
        <category>OpenCV的Python实践</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV的Python实践(2)]]></title>
    <url>%2F2019%2F05%2F18%2FOpenCvPythonPractice-2%2F</url>
    <content type="text"><![CDATA[几何变换—扩展缩放 &emsp;&emsp;只是改变图像的尺寸大小，cv2.resize()可以实现这个功能。在缩放时推荐cv2.INTER_AREA，在拓展时推荐cv2.INTER_CUBIC（慢）和cv2.INTER_LINEAR。默认情况下所有改变图像尺寸大小的操作使用的是插值法都是cv2.INTER_LINEAR。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2 img = cv2.imread('psb.jpg')#下面的None本应该是输出图像的尺寸，但是因为后面设置了缩放因子，所以，这里为Noneres = cv2.resize(img,None,fx=2,fy=2,interpolation=cv2.INTER_CUBIC)#这里直接设置输出图像的尺寸，所以不用设置缩放因子height,width =img.shape[:2]res = cv2.resize(img,(2*width,2*height),interpolation=cv2.INTER_CUBIC)while(1): cv2.imshow('res',res) cv2.imshow('img',img) if cv2.waitKey(1)&amp;0xFF == 27: breakcv2.destroyAllWindows() 几何变换—平移&emsp;&emsp;如果想要沿（x，y）方向移动，移动的距离为（tx,ty）可以以下面方式构建移动矩阵。&emsp;&emsp;使用Numpy数组构建矩阵，数据类型是np.float32，然后传给函数cv2.warpAffine()函数cv2.warpAffine() 的第三个参数的是输出图像的大小，它的格式应该是图像的（宽，高）。应该记住的是图像的宽对应的是列数，高对应的是行数。1234567891011121314151617#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#将图像平移到到点（200,100）处import cv2import numpy as np img=cv2.imread('psb.jpg')rows,cols=img.shape[:2]M= np.float32([[1, 0, 200], [0, 1, 100]])dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow('img', dst)k = cv2.waitKey(0)if k == ord('s'): cv2.imwrite('show', dst) cv2.destroyAllWindows() 几何变换—旋转&emsp;&emsp;对一个图像旋转角度θ，需要使用下面的旋转矩阵。&emsp;&emsp;但OpenCV允许在任意地方进行旋转，所以矩阵应该为：&emsp;&emsp;为构建旋转矩阵，OpenCV提供了一个函数cv2.getRotationMatrix2D。1234567891011121314151617181920212223#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2img = cv2.imread('psb.jpg',0)rows,cols=img.shape[:2]#这里的第一个参数为旋转中心，第二个为旋转角度，第三个为旋转后的缩放因子#可以通过设置旋转中心，缩放因子以及窗口大小来防止旋转后超出边界的问题。M=cv2.getRotationMatrix2D((cols/2,rows/2),45,0.6)#第三个参数是输出图像的尺寸中心dst=cv2.warpAffine(img,M,(1*cols,1*rows))while(1): cv2.imshow('img',dst) if cv2.waitKey(1)==27: breakcv2.destroyAllWindows() 几何变换—仿射变换&emsp;&emsp;仿射变换就是图像的线性变换加上平移，用一幅图表示，就是&emsp;&emsp;由image1到image2经过了三个操作 旋转(线性变化) 缩放(线性变化) 平移(向量加)如果没有了第3个平移的操作，那它就是线性变换。&emsp;&emsp;图像的变换要对图像的每一个像素点进行操作，假设其中的一个像素点的坐标是（x,y），我们用矩阵形式表示：我们通常使用2x3矩阵来表示仿射变换:经过仿射变换后的点的矩阵坐标是T，我们已经知道仿射变换就是线性变换加上平移，用矩阵表示的话就是:计算可得，点的坐标经过仿射变换后成为：&emsp;&emsp;观察之前平移，旋转的代码，其中的都有dst = cv2.warpAffine(img, M, (cols, rows))，之所以是平移，是旋转，只是其中的变化矩阵M不同。&emsp;&emsp;在仿射变换中，原图中所有平行线在结果图像中同样平行。为创建这个矩阵，需要从原图像中找到三个点以及他们在输出图像中的位置，然后cv2.getAffineTransForm()会创建一个2X3的矩阵。最后这个矩阵会被传给函数cv2.warpAffine()。123456789101112131415161718192021#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg')rows,cols,ch=img.shape[:3]pts1=np.float32([[0,0],[cols-1,0],[0,rows-1]])pts2=np.float32([[cols*0.2,rows*0.1],[cols*0.9,rows*0.2],[cols*0.1,rows*0.9]])M=cv2.getAffineTransform(pts1, pts2)dst=cv2.warpAffine(img, M, (cols, rows))while(1): cv2.imshow('img',dst) if cv2.waitKey(1)==27: breakcv2.destroyAllWindows() 几何变换—透视变换&emsp;&emsp;对于视角变换，我们需要一个3x3变换矩阵。在变换前后直线还是直线。需要在原图上找到4个点，以及他们在输出图上对应的位置，这四个点中任意三个都不能共线，可以有函数cv2.getPerspectiveTransform()构建，然后这个矩阵传给函数cv2.warpPerspective()。123456789101112131415161718192021#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread('psb.jpg')rows,cols,ch=img.shape[:3]pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]])M=cv2.getPerspectiveTransform(pts1,pts2)dst=cv2.warpPerspective(img,M,(cols,rows))while(1): cv2.imshow('img',dst) if cv2.waitKey(1)==27: breakcv2.destroyAllWindows() 旋转和平移都是仿射变换的特殊形式OpenCV中提供warpAffine函数用来实现仿射变换,该函数要求提供用来进行仿射变换的矩阵（2x3），如果不知道该变换矩阵，可以结合两幅图像上三对对应点利用getAffineTransform函数求得仿射变换矩阵。透视变换的本质是将图像投影到一个新的视平面。仿射变换可以理解为透视变换的特殊形式。一幅图像就是一个像素坐标系下的各个带有像素值的坐标点，而透视变换可以理解为就是将一幅图像中的这些坐标点完成了一个坐标转换，将它们的坐标变换到了其他位置，从而实现了变换了图像视角的效果。透视变换可以用透视变换矩阵完成，透视变换矩阵为3x3矩阵:矩阵可以分块来看，T1表示图像线性变换（包括旋转和缩放）、T2表示图像平移，T3用于产生图像透视变换，a33一般为1。透视变换矩阵一般有8个未知数，给定透视变换对应的四对像素点坐标，即可求得透视变换矩阵；反之，给定透视变换矩阵，即可对图像或像素点坐标完成透视变换。仿射变换需要三组点的对应关系，而透视变换需要四组点的对应关系，才可以分别求得仿射变换和透视变换的变换矩阵。 简单阀值&emsp;&emsp;实现函数为cv2.threshold , cv2.adaptiveThreshold等&emsp;&emsp;当像素值高于阀值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。这个函数就是cv2.threshold()。这个函数的第一个参数就是原图像，原图像应该是灰度图。第二个参数就是用来对像素值进行分类的阀值，第三个参数就是当像素值高于（或者小于）阀值时，应该被赋予新的像素值。OpenCV提供了多种不同的阀值方法，这是有第四个参数来决定的。方法包括 cv2.THRESH_BINARY cv2.THRESH_BINARY_INV cv2.THRESH_TRUNC cv2.THRESH_TOZERO cv2.THRESH_TOZERO_INV1234567891011121314151617181920212223#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb3.jpg')ret , thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)ret , thresh2 = cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV)ret , thresh3 = cv2.threshold(img,127,255,cv2.THRESH_TRUNC)ret , thresh4 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO)ret , thresh5 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO_INV)titles = ['original image','Binary','binary-inv','trunc','tozero','tozero-inv']images = [img,thresh1,thresh2,thresh3,thresh4,thresh5]for i in range(6): plt.subplot(2,3,i+1),plt.imshow(images[i],'gray') plt.title(titles[i]) plt.xticks([]),plt.yticks([])plt.show() 自适应阀值&emsp;&emsp;根据图像上的每一个小区域计算与其对应的阀值。因此在同一幅图像上的不同区域采用的是不同的阀值，从而使我们能在亮度不同的情况下得到更好的结果。&emsp;&emsp;这种方法需要我们指定三个参数，返回值只有一个: Adaptive Method :指定计算阀值的方法 cv2.ADAPTIVE_THRESH_MEAN_C:阀值取自相邻区域的平均值 cv2.ADAPTIVE_THRESH_GAUSSIAN_C:阀值取自相邻区域的加权和，权重为一个高斯窗口 Block Size :邻域大小（用来计算阀值的区域大小） C :这就是一个常数，阀值就等于的平均值或者加权平均值减去这个常数。1234567891011121314151617181920212223242526#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb3.jpg',0)#中值滤波img = cv2.medianBlur(img,5)ret , th1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)# 11为block size，2为C值th2 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_MEAN_C , cv2.THRESH_BINARY,11,2 )th3 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C , cv2.THRESH_BINARY,11,2)titles = ['original image' , 'global thresholding (v=127)','Adaptive mean thresholding', 'adaptive gaussian thresholding']images = [img,th1,th2,th3]for i in range(4): plt.subplot(2,2,i+1),plt.imshow(images[i],'gray') plt.title(titles[i]) plt.xticks([]),plt.yticks([])plt.show() Otsu’s二值化&emsp;&emsp;在使用全局阈值时，随便给了一个数来做阈值，那怎么知道选取的这个数的好坏呢？答案就是不停的尝试。如果是一副双峰图像（简单来说双峰图像是指图像直方图中存在两个峰）呢？我们岂不是应该在两个峰 之间的峰谷选一个值作为阈值？这就是Otsu二值化要做的。简单来说就是对一副双峰图像自动根据其直方图计算出一个阈值。（对于非双峰图像，这种方法得到的结果可能会不理想）。&emsp;&emsp;这里用到到的函数还是 cv2.threshold()，但是需要多传入一个参数 （ﬂag）：cv2.THRESH_OTSU。这时要把阈值设为 0。然后算法会找到最优阈值，这个最优阈值就是返回值 retVal。如果不使用 Otsu 二值化，返回的 retVal 值与设定的阈值相等。1234567891011121314151617181920212223242526272829303132333435#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb3.jpg',0)ret1,th1=cv2.threshold(img,127,255,cv2.THRESH_BINARY)ret2,th2=cv2.threshold(img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)#(5,5)为高斯核的大小，0为标准差blur= cv2.GaussianBlur(img,(5,5),0)#阀值一定要设为0ret3,th3=cv2.threshold(blur,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)images=[img,0,th1, img,0,th2, img,0,th3]titles =['original noisy image','histogram','global thresholding(v=127)', 'original noisy image','histogram',"otsu's thresholding", 'gaussian giltered image','histogram',"otus's thresholding"]#这里使用了pyplot中画直方图的方法，plt.hist要注意的是他的参数是一维数组#所以这里使用了（numpy）ravel方法，将多维数组转换成一维，也可以使用flatten方法for i in range(3): plt.subplot(3,3,i*3+1),plt.imshow(images[i*3],'gray') plt.title(titles[i*3]),plt.xticks([]),plt.yticks([]) plt.subplot(3,3,i*3+2),plt.hist(images[i*3].ravel(),256) plt.title(titles[i*3+1]),plt.xticks([]),plt.yticks([]) plt.subplot(3,3,i*3+3),plt.imshow(images[i*3+2],'gray') plt.title(titles[i*3+2]),plt.xticks([]),plt.yticks([]) plt.show() 2D卷积同一维信号一样，可以对2D图像实施低通滤波（LPF）和高通滤波（HPF）。LPF用于去除噪音，模糊图像，HPF用于找到图像的边缘。OpenCV提供的函数cv.filter2D()可以对一幅图像进行卷积操作。练习一幅图像使用平均滤波器。举例下面是一个5X5的平均滤波器核：操作如下，将核放在图像的一个像素A上，求与核对应的图像上25（5x5）个像素的和，再取平均数，用这个平均数代替像素A的值。重复以上操作直到将图像的每一个像素值都更新一遍。1234567891011121314151617181920212223242526272829#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')kernel = np.ones((5,5),np.float32)/25#cv.Filter2D(src, dst, kernel, anchor=(-1, -1))#ddepth –desired depth of the destination image;#if it is negative, it will be the same as src.depth();#the following combinations of src.depth() and ddepth are supported:#src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F#src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F#src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F#src.depth() = CV_64F, ddepth = -1/CV_64F#when ddepth=-1, the output image will have the same depth as the source.dst = cv2.filter2D(img,-1,kernel)plt.subplot(121),plt.imshow(img),plt.title('original')plt.xticks([]),plt.yticks([])plt.subplot(122),plt.imshow(dst),plt.title('averaging')plt.xticks([]),plt.yticks([])plt.show() 平均这是由一个归一化卷积框完成的，他只是用卷积框覆盖区域所有像素的平均值来代替中心元素。可以使用cv2.blur()和cv2.boxFilter()来实现， 我们需要设定卷积框的宽和高。同样是一个矩阵。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')blur = cv2.blur(img,(5,5))while(1): cv2.imshow('image',img) cv2.imshow('blur',blur) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 高斯模糊&emsp;&emsp;现在把卷积核换成高斯核，简单的说方框不变，将原来每个方框的值是相等的，现在里面的值是符合高斯分布的，方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包，原来的求平均数变成求加权平均数，权就是方框里的值。实现的函数是cv2.GaussianBlur()。需要指定高斯核的宽和高（必须是奇数），以及高斯函数沿X,Y方向的标准差。如果我们只指定了X方向的标准差，Y方向也会取相同值，如果两个标准差都是0.那么函数会根据核函数的大小自己计算，高斯滤波可以有效的从图像中去除高斯噪音。&emsp;&emsp;也可以使用cv2.getGaussianKernel()自己构建一个高斯核。&emsp;&emsp;如果要使用高斯模糊的话，上边的代码应改成：1234567891011121314151617181920#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('psb.jpg')# 0是指根据窗口大小（5,5）来计算高斯函数标准差blur = cv2.GaussianBlur(img,(5,5),0)while(1): cv2.imshow('image',img) cv2.imshow('blur',blur) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 中值模糊就是用与卷积框对应像素的中值来替代中心像素的值，这个滤波器经常用来去除椒盐噪声。前面的滤波器都是用计算得到的一个新值来取代中心像素的值，而中值滤波是用中心像素周围或者本身的值来取代他，他能有效去除噪声。卷积核的大小也应该是一个奇数。需要给原始图像加上50%的噪声，然后用中值模糊。123456789101112131415161718#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg')median = cv2.medianBlur(img,5)while(1): cv2.imshow('image',img) cv2.imshow('blur',median) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 双边滤波函数cv2.bilateralFilter()能在保持边界清晰的情况下有效的去除噪音，但比较慢。这种高斯滤波器只考虑像素之间的空间关系，而不会考虑像素值之间的关系（像素的相似度），所以这种方法不会考虑一个像素是否位于边界，因此边界也会被模糊掉。双边滤波在同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以能保证边界不会被模糊，因此边界处的灰度值变化比较大。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg')# 9 邻域直径，两个 75 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差 blur = cv2.bilateralFilter(img,9,75,75)while(1): cv2.imshow('image',img) cv2.imshow('blur',blur) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–腐蚀&emsp;&emsp;形态学转换原理：一般情况下对二值化图像进行操作。需要两个参数，一个是原始图像，第二个被称为结构化元素或者核，它是用来决定操作的性质的。基本操作为腐蚀和膨胀，他们的变体构成了开运算，闭运算，梯度等。常用函数cv2.erode(),cv2.dilate(),cv2.morphotogyEx()。&emsp;&emsp;腐蚀：把前景物体的边界腐蚀掉，但是前景仍然是白色的。卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是1，那么中心元素就保持原来的像素值，否则就变为零。根据卷积核的大小靠近前景的所有像素都会被腐蚀掉（变为0），所以前景物体会变小，整幅图像的白色区域会减少。这对于去除白噪音很有用，也可以用来断开两个连在一块的物体。123456789101112131415161718#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)erosion = cv2.erode(img,kernel,iterations=1)while(1): cv2.imshow('image',img) cv2.imshow('erosion',erosion) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–膨胀&emsp;&emsp;与腐蚀相反，与卷积核对应的原图像的像素值中只要有一个是1，中心元素的像素值就是1。所以这个操作会增加图像中白色区域（前景）。一般在去噪音时先腐蚀再膨胀，因为腐蚀再去掉白噪音的同时，也会使前景对象变小，所以我们再膨胀。这时噪音已经被去除，不会再回来了，但是前景还在并会增加，膨胀也可以用来连接两个分开的物体。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)dilation = cv2.dilate(img,kernel,iterations=1)while(1): cv2.imshow('image',img) cv2.imshow('dilation',dilation) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–开运算先进行腐蚀再进行膨胀就叫做开运算。被用来去除噪音，函数可以使用cv2.morphologyEx()12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)opening = cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel)while(1): cv2.imshow('image',img) cv2.imshow('opening',opening) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–闭运算先膨胀再腐蚀。被用来填充前景物体中的小洞，或者前景上的小黑点。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)closing = cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel)while(1): cv2.imshow('image',img) cv2.imshow('closing',closing) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–梯度其实就是一幅图像膨胀与腐蚀的差别。结果看上去就像前景物体的轮廓。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)gradient = cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel)while(1): cv2.imshow('image',img) cv2.imshow('gradient',gradient) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–礼帽原始图像与进行开运算之后得到的图像的差。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)tophat = cv2.morphologyEx(img,cv2.MORPH_TOPHAT,kernel)while(1): cv2.imshow('image',img) cv2.imshow('tophat',tophat) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows() 形态学–黑帽进行闭运算之后得到的图像与原始图像的差。12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg = cv2.imread('psb.jpg',0)kernel = np.ones((5,5),np.uint8)blackhat = cv2.morphologyEx(img,cv2.MORPH_BLACKHAT,kernel)while(1): cv2.imshow('image',img) cv2.imshow('blackhat',blackhat) k=cv2.waitKey(1) if k == ord('q'):#按q键退出 breakcv2.destroyAllWindows()]]></content>
      <categories>
        <category>OpenCV的Python实践</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV的Python实践(1)]]></title>
    <url>%2F2019%2F05%2F16%2FOpenCvPythonPractice-1%2F</url>
    <content type="text"><![CDATA[升级pip window的cmd模式下查询当前pip版本1python -m pip show pip window的cmd模式下升级pip1python -m pip install --upgrade pip &emsp;&emsp;安装cv2的时候出现”Requirement already satisfied”的问题无法使用python -m pip install opencv-python自动安装，可能是因为我的python版本经常换来换去的原因。通过指定安装路径解决，启动自动安装。1python -m pip install --target=D:\Python27_13\Lib\site-packages opencv-python &emsp;&emsp;好吧，可能因为网络原因，我的网是真的慢，安装到一半还是失败，但是获取了相关whl的信息，我直接去下载这个opencv_python-4.1.0.25-cp36-cp36m-win32.whl来手动安装。用迅雷下载这个25兆的文件用了将近5分钟。–upgrade –target= 安装时强制替换更新老版本123python -m pip install --upgrade --target=D:\Python27_13\Lib\site-packages D:\numpy-1.16.3-cp36-cp36m-win32.whlpython -m pip install --upgrade --target=D:\Python27_13\Lib\site-packages D:\opencv_python-4.1.0.25-cp36-cp36m-win32.whlpython -m pip install --upgrade --target=D:\Python27_13\Lib\site-packages D:\matplotlib-3.0.3-cp36-cp36m-win32.whl 环境配置成功 显示保存图片12345678910111213141516171819202122232425262728#!D:\Python34\python.exe# -*- coding: utf-8 -*-#python3.6.8#显示保存图片import cv2 import numpy as npimport matplotlib # python -m pip install matplotlib-3.0.3-cp36-cp36m-win32.whl#print("cv2版本"+cv2.__version__)#print(np.version.version)#print(matplotlib.__version__)#读取图片img=cv2.imread('arterialImg.png',cv2.IMREAD_GRAYSCALE) img2=cv2.imread('arterialImg.png',cv2.IMREAD_COLOR) #cv2.IMREAD_COLOR 彩色模式忽略透明度，cv2.IMREAD_GRAYSCALE 灰度模式#显示图片cv2.imshow('image',img)cv2.imshow('image2',img2)k=cv2.waitKey(0) #0毫秒内无限等待键盘输入，检测键是否按下if k==27: cv2.destroyAllWindows() #ESC按下elif k==ord('s'): #print("保存图片") #cv2.imwrite("mess.jpg",img) cv2.destroyAllWindows()cv2.destroyAllWindows() print("结束") 使用MatplotlibMatplotlib是python的一个绘图库，包含各种各样的绘图方法。 123456789101112131415161718#!D:\Python34\python.exe# -*- coding: utf-8 -*-#python3.6.8#使用Matplotlibimport cv2 import numpy as npfrom matplotlib import pyplot as pltfrom matplotlib.font_manager import FontPropertiesfont_set=FontProperties(fname=r"c:\windows\fonts\simsun.ttc",size=12)img=cv2.imread('arterialImg.png',cv2.IMREAD_COLOR) plt.imshow(img,cmap='gray',interpolation='bicubic')plt.xlabel(u'年份',fontproperties=font_set)plt.ylabel(u'产量',fontproperties=font_set)plt.legend(prop=font_set,loc='best')plt.title("裤子",fontproperties=font_set)plt.show() 使用摄像头捕获视频123456789101112131415161718#!D:\Python34\python.exe# -*- coding: utf-8 -*-#python3.6.8#使用摄像头捕获视频import cv2 import numpy as npcap=cv2.VideoCapture(0)while(True): ret,frame=cap.read() gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) cv2.imshow('frame',gray) if cv2.waitKey(1)&amp; 0xFF == ord('q'): breakcap.release()cv2.destroyAllWindows() &emsp;&emsp;cap.isOpened()可检查摄像头设备是否初始化，如果返回True则没问题，否则要使用cap.open()&emsp;&emsp;cap.get(propid)可获取视频一些参数信息，propid于0–18之间,如cap.get(3)和cap.get(4)可查看每帧宽和高&emsp;&emsp;cap.set(propid,value)可修改视频属性，如cap.set(3,320)将视频宽度设置为320 从文件中播放视频12345678910111213141516171819#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#从文件中播放视频import cv2import numpy as npcap = cv2.VideoCapture("../JustTheWayYouAre.mp4")while(1): #获取一帧图像 ret, frame = cap.read() #显示一帧图像 cv2.imshow("capture", frame) if cv2.waitKey(25) &amp; 0xFF == ord('q'): breakcap.release()cv2.destroyAllWindows() #cv2.waitKey(25) 代表一帧25毫秒，这可以控制播放速度 保存视频&emsp;&emsp;OpenCV是计算机视觉库，可以把图片序列保存成视频(也是基于vfw和ffmpeg的)，但它本身并不是视频编码解码器，只支持avi的格式，而且生成的视频文件不能大于2GB，不能添加音频。如果想突破这些限制，还是得用ffMpeg。&emsp;&emsp;捕获视频，并对每一帧进行加工后想要保存这个视频。&emsp;&emsp;保存视频需要创建一个VideoWriter对象，确定输出文件的名字，指定FourCC编码，帧大小，播放频率和isColor标签。&emsp;&emsp;有一个比较坑的地方，opencv修改后保存视频的帧大小宽高必须与原始视频保持一致才行。1234567891011121314151617181920212223242526272829#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#打开一个本地视频，将每帧图像翻转后保存为另一个视频。import cv2import numpy as npcap = cv2.VideoCapture("../JustTheWayYouAre.mp4")frame_width = int(cap.get(3))frame_height = int(cap.get(4))#需要去http://www.fourcc.org/downloads/divx-912-7/start下载DIVX编码器fourcc = cv2.VideoWriter_fourcc(*'XVID')out = cv2.VideoWriter('output.avi',fourcc, 20.0, (frame_width,frame_height))while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,0) out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break cap.release()out.release()cv2.destroyAllWindows() 线,矩形,圆,椭圆,多边形,添加文字需要使用这些函数cv2.line(),cv2.rectangle(),cv2.circle(),cv2.ellipse(),cv2.putText()上面函数都需要设置的共同参数： img：想要绘制图形的那张图 color：形状的颜色，rgb需要传入一个元组，灰度图只需传入灰度值。 thickness：线条粗细。默认为1。如果一个闭合图形设置为-1，该图形被填充。 linetype：线条类型，8连通、抗锯齿等。(并不是指线型是实线、虚线还是点画线，这个参数实际用途是改变线的产生算法)，默认8连通，cv2.LINE_AA为抗锯齿，使线条看起来平滑。 &emsp;&emsp;画线，需要指定线的起点和终点。&emsp;&emsp;画矩形，需要指定左上角顶点和右下角顶点。&emsp;&emsp;画圆，需要指定圆形中心点坐标和半径大小。&emsp;&emsp;画椭圆，需要指定椭圆的中心点坐标、长轴和短轴长度、椭圆沿逆时针旋转的角度，椭圆弧沿顺时针方向起始角度和结束角度(0-360代表整个椭圆)。&emsp;&emsp;画多边形，需要指定每个顶点的坐标。cv2.polylines()可用来画很多线，只需要将要画的线放在一个列表里传给函数即可。每条线被独立绘制，这比cv2.line()一条一条绘制要快一些。&emsp;&emsp;在图片上添加文字，需要设置下列参数：要绘制文字、要绘制的位置、字体类型(通过查看cv2.putText()的文档找到支持字体)、字体的大小、文字的一般属性，如颜色、粗细、线条类型等，为美观一般linetype=cv2.LINE_AA。&emsp;&emsp;所有绘图函数返回值都是None，所以img1=cv2.line(img,(0,0),(511,511),(255,0,0),5)是错误的。12345678910111213141516171819202122232425262728#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#线,矩形,圆,椭圆,多边形,添加文字import cv2import numpy as npimg=np.zeros((512,512,3),np.uint8)#画线cv2.line(img,(0,0),(511,511),(255,0,0),5)#图片上添加文字font=cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2)#画矩形cv2.rectangle(img,(384,0),(510,128),(0,255,0),3)#画圆cv2.circle(img,(447,63), 63, (0,0,255), -1)#画椭圆cv2.ellipse(img,(256,256),(100,50),30,0,360,255,3)#画多边形pts=np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts=pts.reshape((-1,1,2))cv2.polylines(img,[pts],True,(0,0,255),3)#如果去掉中括号，只是画四个点。如果第三个参数为False，多边形不闭合首尾不相连，cv2.imshow('opencv',img)cv2.waitKey(0)cv2.destroyAllWindows() 鼠标回调事件1234567891011121314151617181920212223#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#鼠标回调事件import cv2import numpy as npdef draw_circle(event,x,y,flags,param): if event==cv2.EVENT_LBUTTONDBLCLK: cv2.circle(img,(x,y),100,(255,0,0),-1) img=np.zeros((512,512,3),np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image',draw_circle)while(1): cv2.imshow('image',img) if cv2.waitKey(20)&amp;0xFF==27: # esc退出 breakcv2.destroyAllWindows() 按下拖拽鼠标，mode为true绘制矩形，为False绘制曲线，按M切换12345678910111213141516171819202122232425262728293031323334353637#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npdrawing=Falsemode=Trueix,iy=-1,-1def draw_circle(event,x,y,flags,param): global ix,iy,drawing,mode if event==cv2.EVENT_LBUTTONDOWN: drawing=True ix,iy=x,y elif event==cv2.EVENT_MOUSEMOVE and flags==cv2.EVENT_FLAG_LBUTTON: if drawing==True: if mode==True: cv2.rectangle(img,(ix,iy),(x,y),(0,255,0),-1) else: cv2.circle(img,(x,y),3,(0,0,255),-1) elif event==cv2.EVENT_LBUTTONUP: drawing==Falseimg=np.zeros((512,512,3),np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image',draw_circle)while(1): cv2.imshow('image',img) k=cv2.waitKey(1)&amp;0xFF if k==ord('m'): mode=not mode elif cv2.waitKey(20)&amp;0xFF==27: # esc退出 breakcv2.destroyAllWindows() 滑动条&emsp;&emsp;通过调节滑动条设定画板颜色。&emsp;&emsp;cv2.getTrackbarPos()的参数分别为滑动条名字、滑动条被放置窗口的名字、滑动条默认位置、滑动条最大值、回调函数。每次滑动条滑动都会调用回调函数，回调函数的默认参数就是滑动条的位置。12345678910111213141516171819202122232425262728293031323334353637#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npdrawing=Falsemode=Trueix,iy=-1,-1def nothing(x): passimg=np.zeros((512,512,3),np.uint8)cv2.namedWindow('image')cv2.createTrackbar('R','image',0,255,nothing)cv2.createTrackbar('G','image',0,255,nothing)cv2.createTrackbar('B','image',0,255,nothing)switch='0:off\n1:on'cv2.createTrackbar(switch,'image',0,1,nothing)while(1): cv2.imshow('image',img) k=cv2.waitKey(1)&amp;0xFF if k==27: #esc退出 break r=cv2.getTrackbarPos('R','image') g=cv2.getTrackbarPos('G','image') b=cv2.getTrackbarPos('B','image') s=cv2.getTrackbarPos(switch,'image') if s==0: img[:]=0 else: img[:]=[b,g,r]cv2.destroyAllWindows() 获取并修改像素值&emsp;&emsp;cv2.imread()读取的图片默认情况下为彩图（三通道图片），所以，在定位到对应(x,y)像素点上的时候，得到的就是三维向量。numpy的操作基于性能考虑，能用矩阵运算就不用循环。1234567891011121314151617181920#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread("psb.jpg")print(img.shape) #返回图像的属性，包括(行，列，通道数)print(img.size) #图像的像素数目print(img.dtype) #图像的数据类型p=img[100,100] #获取某点属性print(p)px=img.item(100,100,0) py=img.item(100,100,1) pz=img.item(100,100,2) print(str(px)+' '+str(py)+" "+str(pz)) #分别获取某点的rgb各值 img.itemset((100,100,2),138) #设置某分量的值pz=img.item(100,100,2)print(str(pz)) 图像ROI&emsp;&emsp;ROI全称Region Of Internet，感兴趣的区域，就是从图像中选择一个图像区域。&emsp;&emsp;下面代码将一块感兴趣的区域，复制到了另一个地方，或者单独提取出来。1234567891011121314151617#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread("psb.jpg")source=img[280:340,330:390]img[273:333,100:160]=source #感兴趣的区域复制到了另一个地方cv2.imshow('image',img)cv2.imshow('dandu',source) #感兴趣的区域单独提取出来k=cv2.waitKey(0) #0毫秒内无限等待键盘输入，检测键是否按下if k==27: cv2.destroyAllWindows() #ESC按下cv2.destroyAllWindows() 拆分通道及合并通道v2.split函数分离得到各个通道的灰度值(单通道图像)。cv2.merge函数是合并单通道成多通道（不能合并多个多通道图像）。12345678910111213141516171819202122232425262728#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npimg=cv2.imread("psb.jpg")b,g,r=cv2.split(img)print("img shape "+str(img.shape))print("r shape "+str(r.shape))cv2.imshow('r ',r)cv2.imshow('g ',g)cv2.imshow('b ',b)#生成一个值为0的单通道数组zeros = np.zeros(img.shape[:2], dtype = "uint8")# 分别扩展B、G、R成为三通道。另外两个通道用上面的值为0的数组填充cv2.imshow("Blue", cv2.merge([b, zeros, zeros]))cv2.imshow("Green", cv2.merge([zeros, g, zeros]))cv2.imshow("Red", cv2.merge([zeros, zeros, r]))img[:,:,2]=0#所有像素的红通道值为0 BGRcv2.imshow("Blue+Green", img)img[:,:,1]=0#所有像素的绿通道值为0 前两个选所有像素，最后一个选通道img[:,:,0]=0#所有像素的蓝通道值为0 k=cv2.waitKey(0) if k==27: cv2.destroyAllWindows() #ESC按下cv2.destroyAllWindows() 图像加法使用cv2.add()将两幅图像进行加法运算，也可以直接使用numpy，res=img1+img2.两幅图像的大小，类型必须一致，或者第二个图像可以是一个简单的标量值。openCV的加法是一种饱和操作，而numpy的加法是一种模操作。12345678910111213#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as np x=np.uint8([250])y=np.uint8([10])print(cv2.add(x,y))#250+10=260&gt;=255#结果为[[255]]print (x+y)#250+10=260%255=4#结果为[4] 图像混合这也是加法，不同的是两幅图像的权重不同，这会给人一种混合或者透明的感觉。图像混合的计算公式如下：g(x) = (1−α)f0(x)+αf1(x)通过修改α的值（0~1）,可以实现很酷的混合。例：将两幅图像混合，第一幅权重为0.7.第二幅权重为0.3。函数cv2.addWeighed()可以按下面的公式对图片进行混合。dst = α·img1 + β·img2+γ 这里γ的取值为0.123456789101112131415#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as np img1=cv2.imread('psb.jpg')img2=cv2.imread('psb3.jpg')dst = cv2.addWeighted(img1,0.7,img2,0.3,0)cv2.imshow('dst',dst)cv2.waitKey(0)cv2.destroyAllWindows() 123456789101112131415161718192021222324252627282930#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as np def nothing(x): pass img1 = cv2.imread('psb.jpg')img2 = cv2.imread('psb3.jpg')#创建一个黑色背景的窗口img = np.zeros((400,400,3), np.uint8)cv2.namedWindow('image') cv2.createTrackbar('a','image',0,100,nothing) while(1): cv2.imshow('image',img) k = cv2.waitKey(1) &amp; 0xFF if k == 27: break r = cv2.getTrackbarPos('a','image') r=float(r)/100.0 img=cv2.addWeighted(img1,r,img2,1.0-r,0)cv2.destroyAllWindows() 阈值二值化和位运算&emsp;&emsp;图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。&emsp;&emsp;一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。&emsp;&emsp;位运算操作有and, or, not, xor。在提取部分图像选择非矩形区域roi时，位运算操作十分有用。&emsp;&emsp;把opencv的标志放到另外一副图像上，如果使用加法，颜色会改变，如果使用混合，会变成透明，如果是矩形区域，可以使用roi方法，不是矩形时，用位运算实现。12345678910111213141516171819202122232425262728293031#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as np baidu_logo = cv2.imread('baidu.png')target_img=cv2.imread('target.jpg')#图片相加需要有相同的宽和高，所以先构建一个新的图片baidu_resize，大小和目的图片相同baidu_resize = np.ones(target_img.shape,np.uint8)baidu_resize =baidu_resize *255 # 得到白色背景#baidu_resize =baidu_resize *0 # 得到黑色色背景#把baidu_logo图像放入生成的指定长宽大小的图像里baidu_resize[0:baidu_logo.shape[0], 0:baidu_logo.shape[1]] = baidu_logo#得到灰度图baidu_logo_gray = cv2.cvtColor(baidu_resize, cv2.COLOR_BGR2GRAY)#阈值二值化，灰度值大于200的像素点位置赋值255，其他像素点位置赋值0ret, mask = cv2.threshold(baidu_logo_gray, 200, 255, cv2.THRESH_BINARY) #取反操作，mask中255的像素点值变为0， 值为0的像素点新值为255mask_inv = cv2.bitwise_not(mask) #对图像应用maskbaidu_logo_fg = cv2.bitwise_and(baidu_resize, baidu_resize, mask = mask_inv)target_img_bg = cv2.bitwise_and(target_img, target_img, mask = mask)#图像相加融合，得到最终结果added_img = cv2.add(baidu_logo_fg, target_img_bg)cv2.imshow('final',added_img)cv2.waitKey(0)cv2.destroyAllWindows() 图像的运算&emsp;&emsp;图像的基本运算有很多种，比如两幅图像可以相加、相减、相乘、相除、位运算、平方根、对数、绝对值等；图像也可以放大、缩小、旋转，还可以截取其中的一部分作为ROI（感兴趣区域）进行操作，各个颜色通道还可以分别提取及对各个颜色通道进行各种运算操作。总之，对于图像可以进行的基本运算非常的多。&emsp;&emsp;基础数学运算应用于图像像素处理：1234567891011void add(InputArray src1, InputArray src2, OutputArray dst,InputArray mask=noArray(), int dtype=-1);//dst = src1 + src2void subtract(InputArray src1, InputArray src2, OutputArray dst,InputArray mask=noArray(), int dtype=-1);//dst = src1 - src2void multiply(InputArray src1, InputArray src2,OutputArray dst, double scale=1, int dtype=-1);//dst = scale*src1*src2void divide(InputArray src1, InputArray src2, OutputArray dst,double scale=1, int dtype=-1);//dst = scale*src1/src2void divide(double scale, InputArray src2,OutputArray dst, int dtype=-1);//dst = scale/src2void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);//dst = alpha*src1 + src2void addWeighted(InputArray src1, double alpha, InputArray src2,double beta, double gamma, OutputArray dst, int dtype=-1);//dst = alpha*src1 + beta*src2 + gammavoid sqrt(InputArray src, OutputArray dst);//计算每个矩阵元素的平方根void pow(InputArray src, double power, OutputArray dst);//src的power次幂void exp(InputArray src, OutputArray dst);//dst = e**src（**表示指数的意思）void log(InputArray src, OutputArray dst);//dst = log(abs(src)) &emsp;&emsp;二进制数据的与、或、非、异或操作应用于图像像素处理：1234void bitwise_and(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 &amp; src2void bitwise_or(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 | src2void bitwise_xor(InputArray src1, InputArray src2,OutputArray dst, InputArray mask=noArray());//dst = src1 ^ src2void bitwise_not(InputArray src, OutputArray dst,InputArray mask=noArray());//dst = ~src 使用OpenCV检测程序效率cv2.getTickCount函数返回从参考点到这个函数被执行的时钟数。在一个函数执行前后都调用它，可以得到这个函数的执行时间。cv2.getTickFrequency返回时钟频率，或者说每秒钟的时钟数。 1234567891011121314151617#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8#窗口大小不同（5,7,9）的核函数来做中值滤波，查看一个函数运行了多少秒import cv2import numpy as np img1 = cv2.imread('psb.jpg')e1 = cv2.getTickCount() #开始计时for i in range(5,49,2): img1 = cv2.medianBlur(img1,i)e2 = cv2.getTickCount() #结束计时time = (e2-e1)/cv2.getTickFrequency()print(time) #中间过程耗时 OpenCV的默认优化cv2.useOptimized()来查看优化是否被开启，cv2.setUesOptimized()来开启优化。1234567891011121314151617181920212223242526272829303132#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2import numpy as npcv2.setUseOptimized(True)print(cv2.useOptimized()) img1 = cv2.imread('psb.jpg')e1 = cv2.getTickCount()for i in range(5,49,2): img1 = cv2.medianBlur(img1,i)e2 = cv2.getTickCount()time = (e2-e1)/cv2.getTickFrequency()print("优化过的耗时："+str(time))cv2.setUseOptimized(False)img1 = cv2.imread('psb.jpg')e1 = cv2.getTickCount()for i in range(5,49,2): img1 = cv2.medianBlur(img1,i)e2 = cv2.getTickCount()time = (e2-e1)/cv2.getTickFrequency()print("取消优化的耗时："+str(time))cv2.setUseOptimized(True)#取消优化后的耗时更短。。。 转换颜色空间&emsp;&emsp;在OpenCV中有超过150种进行颜色空间转换的方法。但是你以后就会发现我们经常用到的也就两种：BGR↔Gray 和 BGR↔HSV。&emsp;&emsp;我们用到的函数是cv2.cvtColor(input_imageﬂag)，其中ﬂag就是转换类型。&emsp;&emsp;对于BGR↔Gray的转换，我们使用的ﬂag就是cv2.COLOR_BGR2GRAY。&emsp;&emsp;同样对于BGR↔HSV的转换我们用的ﬂag就是cv2.COLOR_BGR2HSV。&emsp;&emsp;得到所有可用的颜色空间flag123456789#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2 for i in dir(cv2): if i.startswith('COLOR_'): print(i) &emsp;&emsp;在OpenCV的HSV格式中，H（色彩/色度）的取值范围是[0，179]，S（饱和度）的取值范围[0，255]，V（亮度）的取值范围[0，255]。但是不同的软件使用的值可能不同。所以当你拿OpenCV的HSV值与其他软件的HSV值对比时，一定要记得归一化。 物体跟踪现在我们知怎样将一幅图像从BGR换到HSV了，我们可以利用这点来提取带有某个特定色的物体。在HSV颜色空间中要比在BGR空间中更容易表示一个特定颜色。在我们的程序中，我们提取的是一个蓝色的物体。以下就是我们做的几步： 从视频中获取每一帧图像 将图像转换到HSV空间 设置HSV阈值到蓝色范围 获取蓝色物体123456789101112131415161718192021222324252627282930#!D:\Python27_13\python.exe# -*- coding: utf-8 -*-#python3.6.8import cv2 import numpy as npcap = cv2.VideoCapture(0)while(1): #获取每一帧 ret,frame = cap.read() #转换到HSV hsv = cv2.cvtColor(frame,cv2.COLOR_BGR2HSV) #设定蓝色的阀值 lower_blue = np.array([110,50,50]) upper_blue = np.array([130,255,255]) #根据阀值构建掩模 mask = cv2.inRange(hsv,lower_blue,upper_blue) #对原图和掩模进行位运算 res = cv2.bitwise_and(frame,frame,mask=mask) #显示图像 cv2.imshow('frame',frame) cv2.imshow('mask',mask) cv2.imshow('res',res) k = cv2.waitKey(5)&amp;0xFF if k == 27: break#关闭窗口cv2.destroyAllWindows()]]></content>
      <categories>
        <category>OpenCV的Python实践</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础语法]]></title>
    <url>%2F2019%2F05%2F15%2FfirstBlog%2F</url>
    <content type="text"><![CDATA[标题Markdown支持6种级别的标题，对应html标签h1~h6123456# h1## h2### h3#### h4##### h5###### h6 段落及区块引用Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。 另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示1&gt; 这段文字将被高亮强调显示 这段文字将被高亮强调显示 插入链接或图片引用图片和链接的唯一区别就是在最前方添加一个感叹号。123直接链接：&lt;http://www.baidu.com&gt;[点击跳转至百度](http://www.baidu.com)![图片](https://box.bdimg.com/static/fisp_static/common/img/searchbox/logo_news_276_88_1f9876a.png) 直接链接：http://www.baidu.com点击跳转至百度 列表Markdown支持有序列表和无序列表两种形式：无序列表使用*或+或-标识有序列表使用数字标识 例如1.123456789101112131415* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格 如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格12345678910* 段落一 小段一* 段落二 小段二* 段落一 &gt; 区块标记一* 段落二 &gt; 区块标记二 段落一 小段一 段落二 小段二 段落一 区块标记一 段落二 区块标记二 记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。 分割线12***--- 对部分文字强调123456789*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__上标：O&lt;sub&gt;2&lt;/sub&gt;，下标：3&lt;sup&gt;2&lt;/sup&gt;简称或缩写:The &lt;abbr title=&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;. 这里是斜体这里是斜体 这里是加粗这里是加粗 上标：O2，下标：32The HTML specification is maintained by the W3C. 插入表格三个短斜杠左右的冒号用于控制对齐方式只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 表头 条目一 条目二 项目 项目一 项目二 特殊符号使用反斜杠\插入语法中用到的特殊符号1234567891011121314151617\\ 反斜线\` 反引号\* 星号\_ 底线\&#123; \&#125; 花括号\[ \] 方括号\( \) 括弧\# 井字号\+ 加号\- 减号\. 英文句点\! 惊叹号&amp;copy; &amp; &amp;uml; &amp;trade; &amp;iexcl; &amp;pound;&amp;amp; &amp;lt; &amp;gt; &amp;yen; &amp;euro; &amp;reg; &amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot;X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14; &amp;times; &amp;divide; &amp;raquo; \ 反斜线` 反引号* 星号_ 底线{ } 花括号[ ] 方括号( ) 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 &copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 文字上色Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做：1&lt;font color=&apos;#ff0000&apos;&gt;红色&lt;/font&gt; 红色 代码12345```javascript function test() &#123; console.log(&quot;Hello world!&quot;); &#125;``` 123function test() &#123; console.log("Hello world!");&#125; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charest="utf-8" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type="text/css"&gt; ul&#123;list-style: none;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="text-xxl"&gt;Hello world!&lt;/h1&gt; &lt;p class="text-green"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python的串口通信测试]]></title>
    <url>%2F2018%2F12%2F13%2FSerialPythonTest%2F</url>
    <content type="text"><![CDATA[今天基于Python测试了跟硬件交互信息可能会用的串口通信。感觉串口通信用python开发效率比较高。 上位机相当于一个软件系统，可以用于接收数据、控制数据。即可以对接收到的数据直接发送操控命令来操作数据。上位机可以接收下位机的信号。下位机是一个控制器，是直接控制设备获取设备状况的计算机。上位机发出的命令首先给下位机，下位机再根据此命令解释成相应时序信号直接控制相应设备。下位机不时读取设备状态数据（一般为模拟量），转换成数字信号反馈给上位机。上位机不可以单独使用，而下位机可以单独使用。 串口通信一般分为四大步：打开串口-&gt;配置串口-&gt;读写串口-&gt;关闭串口，还可以在串口上监听读写等事件。一般情况下，设备间通信方式分为并行通信和串行通信。并行通信:数据各个位同时传输,速度快,占用引脚资源多。串行通信:数据按位顺序传输,速度相对较慢,占用引脚资源少. 串行通信按数据传送方向分为: a.单工：数据传输只支持数据在一个方向上传输; b.半双工：允许数据在两个方向上传输。但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；它不需要独立的接收端和发送端，两者可以合并一起使用一个端口; c.全双工：允许数据同时在两个方向上传输。因此，全双工通信是两个单工通信方式的结合，需要独立的接收端和发送端。 串行通信按通信方式分为： a.同步通信：带时钟同步信号传输。在同步通讯中，收发设备上方会使用一根信号线传输信号，在时钟信号的驱动下双方进行协调，同步数据。例如，通讯中通常双方会统一规定在时钟信号的上升沿或者下降沿对数据线进行采样。 b.异步通信：不带时钟同步信号传输。在异步通讯中不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些用于同步的信号位，或者将主题数据进行打包，以数据帧的格式传输数据。通讯中还需要双方规约好数据的传输速率（也就是波特率）等，以便更好地同步。常用的波特率有4800bps、9600bps、115200bps等。在同步通讯中，数据信号所传输的内容绝大部分是有效数据，而异步通讯中会则会包含数据帧的各种标识符，所以同步通讯效率高，但是同步通讯双方的时钟允许误差小，稍稍时钟出错就可能导致数据错乱，异步通讯双方的时钟允许误差较大。1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# IDE为Notepad++，打开 视图-显示符号-显示空格和制表符# 以避免缩进方面的语法错误 #import serialimport re#打开串口serialPort="COM3" #串口baudRate=9600 #波特率ser=serial.Serial(serialPort,baudRate,timeout=6.0)str1="参数设置：串口="str1_unicode=str1.decode("utf-8")str1_gbk=str1_unicode.encode("gbk")str2="，波特率="str2_unicode=str2.decode("utf-8")str2_gbk=str2_unicode.encode("gbk")print str1_gbk+str(serialPort)+str2_gbk+str(baudRate)concent="请输入要发送的数据（非中文）并同时接收数据:"c_unicode=concent.decode("utf-8")c_gbk=c_unicode.encode("gbk")#收,发数据maxloopNum=0;while 1: maxloopNum=maxloopNum+1 str=raw_input(c_gbk) ser.write((str+'\n').encode()) print("等待回应".decode("utf-8").encode("gbk")) revalue=ser.readline().decode("utf-8").encode("gbk") print(revalue) #可以接收中文,串口另一段在6秒内发送过来的信息都会接受并print出来 if(re.search(b'OK',revalue)): break elif(maxloopNum&gt;5): sys.exit(0)ser.close()print("串口通信结束。".decode("utf-8").encode("gbk"))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托管dll的插件式编程思路]]></title>
    <url>%2F2016%2F11%2F30%2FDllPlugins%2F</url>
    <content type="text"><![CDATA[动态加载外部托管式dll，通过Assembly反射得到类型，通过Activator.CreateInstance实例化1234567var plugindir = System.IO.Directory.GetParent(System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName).CreateSubdirectory("startup");foreach (var filesInPlugin in plugindir.GetFiles())&#123; if (filesInPlugin.Extension.ToLower() == ".dll") &#123; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System.Collections;using System;using System.IO;using System.Reflection;using System.Text;public class DynamicLoadDLL &#123; private Assembly ass = null; public DynamicLoadDLL(string dllPath) &#123; this.ass = Assembly.LoadFrom(dllPath); &#125; public Assembly GetAssembly() &#123; return this.ass; &#125; public Type[] GetClass() &#123; return ass.GetTypes(); &#125; public Module[] GetModules() &#123; return ass.GetModules(); &#125; public FileStream[] GetFiles() &#123; return ass.GetFiles(); &#125; &#125;public class LoadClass &#123; private static LoadClass dlc = null; private Type type; private object obj = null; private LoadClass(Assembly ass, string _nameSpace, string classPath) &#123; type = ass.GetType(_nameSpace + "." + classPath); //利用类的命名空间和名称得到类型 obj = Activator.CreateInstance(type); &#125; public static LoadClass GetInstance(Assembly ass, string _nameSpace, string classPath) &#123; if (dlc == null) &#123; dlc = new LoadClass(ass, _nameSpace, classPath); &#125; return dlc; &#125; public PropertyInfo[] GetAttrs() &#123; PropertyInfo[] prop = type.GetProperties(); return prop; //返回属性集 &#125; public MethodInfo[] GetMethods() &#123; MethodInfo[] method = type.GetMethods(BindingFlags.NonPublic); return method; //返回方法集 &#125; public object GetAttrValue(string attrName) &#123; PropertyInfo prop = type.GetProperty(attrName); return prop.GetValue(obj,null); //返回属性值 &#125; public void SetAttrValue(string attrName, string attrValue) &#123; PropertyInfo prop = type.GetProperty(attrName); prop.SetValue(obj,attrValue,null); //设置属性值 &#125; public object GetMethod(string methodName, object[] paras, Type[] types) &#123; MethodInfo method = type.GetMethod(methodName, types); //通过方法名称获得方法 return method.Invoke(obj, paras); //执行方法 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity3d发布webGL可能需要注意的事项]]></title>
    <url>%2F2016%2F10%2F27%2FhelloU3dWebGl%2F</url>
    <content type="text"><![CDATA[浏览器支持: Mozilla Firefox 42,Google Chrome 46,Apple Safari 9.0,MS Internet Explorer 11,MS Edge 13 Safari不支持全屏 Chrome需要大量内存解析js代码，可能导致内存不足 IE11号称支持，但是太慢，导致webgl基本不可用 减小发布包的大小 尝试发布空场景，发布文件的全部大小接近6M。。太大了。其中js代码文件xxx.jsgz4.6M。。 优化png文件之类手段并不能减少发布包大小，因为unity最后实际使用的是自己的内部格式。 删除没用的资源也不行 使用Asset Bundle，而不是Resource，可以减少首次下载包的大小。这些其实web player时代就已经是这样了。 打包Asset Bundle的时候使用LZ4压缩格式。webgl不支持多线程，lzma压缩的bundle会导致主线程解压缩时的卡顿。 使用纹理压缩(DXT(Desktop platforms) or PVRTC)，在webgl中使用Crunch压缩选项。压缩网格（mesh）和动画（Animation） 不要引用System.dll 和 System.Xml.dll，尽量少用第三方dll 尽量只用.Net 2.0 subset API 设置Edit &gt; Project Settings &gt; Player &gt; Other Settings中的Strip Engine Code为选中，不发布无用的代码。在使用asset bundle的时候，选中此项可能会导致有些用户代码被跳过，从而在加载asset bundle的时候出现Could not produce class with ID XXX的错误。可以在项目中增加link.xml文件，强制unity包含指定类。如下：12345&lt;linker&gt; &lt;assembly fullname=&quot;UnityEngine&quot;&gt; &lt;type fullname=&quot;UnityEngine.Collider&quot; preserve=&quot;all&quot;/&gt; &lt;/assembly&gt;&lt;/linker&gt; 设置Edit &gt; Project Settings &gt; Player &gt; Publishing Settings 中的Enable Exceptions popup为None，如果不需要处理异常。 设置memory size为合适的大小 在发布对话框中设置优化等级为fastest 正确配置web服务器，在 http 协议层使用gzip压缩 其他 webgl不支持movietexture，可以用HTML5 video element实现 wengl对GLSLS shader的限制比OpenGL ES 2.0更多 webgl不支持使用用户本地字体，字体必须包含在unity项目中 webgl不支持IP socket，包括C#的Socket库和UnityEngine.Network。可以用WWW。unity提供一套支持webgl的网络API，也可以用javascript的websockets自己实现。 webgl对unity音频API有大量限制 在大部分浏览器中，webgl后台运行时的更新频率会下降到每秒一次 wengl中，gc（垃圾回收）只能在每帧结束后进行，因此下面的代码会导致内存耗尽：12345string hugeString = &quot;&quot;;for (int i = 0; i &lt; 100000; i++)&#123; hugeString += &quot;foo&quot;;&#125;]]></content>
      <categories>
        <category>WrongNotes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web端加载xml时出错]]></title>
    <url>%2F2016%2F10%2F19%2Floadxmlbug%2F</url>
    <content type="text"><![CDATA[web端加载xml时出现XmlException: Text node cannot appear in this state. Line 1, position 1. 错误 用其他工具(我用sbulime)将xml另保存为utf-8，无bom信息头格式即可解决。]]></content>
      <categories>
        <category>WrongNotes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg基础知识]]></title>
    <url>%2F2016%2F04%2F21%2FffmpegIntro%2F</url>
    <content type="text"><![CDATA[帧率： 每秒显示图像数。影响画面流畅度，与画面流畅度成正比。标准影片(NTSC)29.97帧每秒(fps)，电影24帧每秒(fps)，欧洲标准25帧每秒(fps)。高帧速率拥有高品质，但文件尺寸也更大。想要降低带宽和cpu占用，可以选择低帧速率。 关键帧： 常用帧差异压缩图像，帧差异是判断从开始帧起哪些信息发生了变化。称为关键帧。关键帧包含图像所有信息，后来的帧仅包含改变了的信息。一般用途5秒设一个关键帧，RTSP流文件需要增加关键帧保证网络传输可靠性。 码率： 比特率(bps)指每秒传送的比特(bit)数。比特率越高，传送的数据越大。比特率越高越清晰（前提是分辨率保持不变），分辨率越大视频尺寸越大。帧率X分辨率=压缩前的每秒数据量。码率(kbps)指每秒显示的图片进行压缩后的数据量。码率越大，体积越大；码率越小，体积越小。压缩比=压缩前的每秒数据量/码率 分辨率： 度量图像内数据量多少的一个参数，单位ppi。决定视频尺寸和像素量。所谓清晰，是指画面十分细腻，没有马赛克。在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。 时间戳： 音视频同步的最佳方案。选择一个线性递增的参考时钟，生成数据流依据参考时钟上时间给每个数据块打上时间戳。播放时读取数据块上时间戳同时参考当前参考时钟上时间来安排播放。如果数据块开始时间大于当前参考时钟时间则不急于播放改数据块直到参考时钟达到数据块的开始时间。如果数据块开始时间小于当前参考时钟时间则尽快播放这个数据块或索性丢弃以使播放进度追上参考时钟。 FFmpeg是一个开源免费跨平台的自由软件。 提供了录制，转化，流化音视频的完整解决方案。由以下几部分组成：FFmpeg：视频文件转换命令行工具FFserver：基于HTTP,RTSP实时广播多媒体服务器FFplay：媒体播放器Libavcodec：包含所有FFmepg音视频编解码器的库Libavformat：包含所有普通音视格式的解析器和产生器的库 从视频中提取音频，忽略视频1ffmpeg -i abc.mp4 -vn ViedoNo.mp3 从视频中提取视频，忽略音频1ffmpeg -i abc.mp4 -an AudioNo.mp4 将视频，音频合并成一个视频1ffmpeg -i AudioNo.mp4 -i ViedoNo.mp3 -vcodec copy -acodec copy output.mp4 将视频 指定分辨率 导出成序列帧,r指定帧率每秒22帧1ffmpeg -i abc.mp4 -s 1024x768 -r 22 -f image2 image-%5d.jpg 将序列帧合并成视频1ffmpeg -r 22 -i image-%5d.jpg -vcodec mpeg4 video.mp4 在视频第8秒出截一张图1ffmpeg -i abc.mp4 -y -f image2 -ss 8 -t 0.001 -s 350x240 test.jpg 把视频前30帧转换成一张gif1ffmpeg -i abc.mp4 -vframes 30 -y -f gif abc.gif 转换视频格式1ffmpeg -i 00.wmv 00.mp4 播放视频1ffplay file.avi 把视频从1分20秒开始，长度30秒的视频裁剪出来，保存成一个视频1ffmpeg -ss 0:1:20 -t 0:0:30 -i input.avi -vcodec copy -acodec copy output.avi 拼接视频1234ffmpeg -i 1.mp4 -qscale 6 inputfile_01.mpgffmpeg -i 2.mp4 -qscale 6 inputfile_02.mpgcopy /b inputfile_01.mpg+inputfile_02.mpg inputfile_all.mpgffmpeg -i inputfile_all.mpg -qscale 6 outputfile.mpg 压缩视频,通常转成.mp4，采用H.264视频压缩算法和AAC音频压缩算法，视频帧率10fps，音频码率32k1ffmpeg -i input.mp4 -r 10 -b:a 32k output.mp4 增加水印1ffmpeg -i input.mp4 -vf &quot;movie=shuiyin.png[logo];[in][logo]overlay=10:10[out]&quot; out.mp4 将视频转换成ts文件并生成m3u8列表1ffmpeg -i input.mp4 -c:v libx264 -c:a aac -strict -2 -hls_time 10 -hls_list_size 0 output.m3u8 修改视频尺寸1ffmpeg -i input.mp4 -vf scale=400:480 -acodec aac -vcodec h264 output.mp4 视频剪裁,剪裁区域左上角坐标0,420,长宽为1080,8001ffmpeg -i input.mp4 -strict -2 -vf crop=1080:800:0:420 视频输出地址 ffmpeg获取 百度网盘链接：https://pan.baidu.com/s/1SIJ8iHm2po4wZqcg_2DH0A 提取码：xp5j]]></content>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试unity3d遮挡剔除功能]]></title>
    <url>%2F2016%2F04%2F14%2FTestU3dOcclusionCulling%2F</url>
    <content type="text"><![CDATA[unity版本4.6.3，遮挡剔除比以前版本更容易使用，设置好static，直接bake即可，打开Occlusion窗口选中Visualization(其下select a Camera from the scene选中场景里主角camera)可在编辑器里看效果。 经测试，通过遮挡剔除大幅降低了drawcalls，视场景模型不同降低幅度不同。其实所有东西都已经加载进内存了，显示不显示出来能缓解大场景渲染Rendering网格贴图方面压力，想要优化内存还是要从其他如LOD,AssetBundle,机制等方面入手优化内存。 将动态加载和遮挡剔除结合适用，测试可行，发布时的工程和开发搭建场景时的工程要是同一个工程，搭建好场景，bake好遮挡剔除，将需要动态加载的物体导出，从场景里删除。发布时加载原来物体仍有遮挡剔除信息。不便之处可改进流程解决。感觉麻烦。]]></content>
  </entry>
</search>
